{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 Welcome to the course text. This textbook will serve as a reference for the course. Notable Features \u00b6 Simple navigation Search Light / Dark Mode (see above) Interactive code annotations tooltips for acronyms and abbreviations (hover over PSF to try it out) lightbox image zoom read on mobile Use the site navigation bar to navigate to a specific chapter. Use the search feature to find a specific topic. Start Reading \u00b6 The best place to start is Chapter 01 .","title":"Home"},{"location":"#welcome","text":"Welcome to the course text. This textbook will serve as a reference for the course.","title":"Welcome"},{"location":"#notable-features","text":"Simple navigation Search Light / Dark Mode (see above) Interactive code annotations tooltips for acronyms and abbreviations (hover over PSF to try it out) lightbox image zoom read on mobile Use the site navigation bar to navigate to a specific chapter. Use the search feature to find a specific topic.","title":"Notable Features"},{"location":"#start-reading","text":"The best place to start is Chapter 01 .","title":"Start Reading"},{"location":"about/","text":"About \u00b6 This web text was started in the Fall of 2022 as a support text for Software Programming, a course that I instruct a Christian Brother's University in Memphis, TN. There are a number of fantastic books on the subject of Python programming. However, none of the books that I reviewed met my standards to alignment with the introductory requirements of the course while still providing enough depth in coverage of the language. My effort here is an attempt to fill the gap that I have found in the literature. The medium I have chosen is a hosted site-based text. This provides a number of benefits for both author and reader. continuous updates interactive content modern web reading experience that is a readable on mobile as it is on desktop I hope that this book serves as a faithful introduction to the Python language. Wherever necessary or beneficial to the reader, I will lean on references to sources in the vast body of work where other authors have shared their experise. Python Version \u00b6 Python version 3.10 is the target version for this text, however the majority of examples and language features discussed in the text are compatible with Python versions 3.6 or higher. Note that as of October 2022, Python 3.10 is the current stable release of the language, it is not the current defacto standard in use. That is to say that many widely used products have not adopted 3.10. For example, if you sign up for a free Google Colab account and begin authoring Python notebooks there, the Python version will likely be 3.8. When in doubt about language features, one can always reference the official documentation and select the correct version from the dropdown.","title":"About"},{"location":"about/#about","text":"This web text was started in the Fall of 2022 as a support text for Software Programming, a course that I instruct a Christian Brother's University in Memphis, TN. There are a number of fantastic books on the subject of Python programming. However, none of the books that I reviewed met my standards to alignment with the introductory requirements of the course while still providing enough depth in coverage of the language. My effort here is an attempt to fill the gap that I have found in the literature. The medium I have chosen is a hosted site-based text. This provides a number of benefits for both author and reader. continuous updates interactive content modern web reading experience that is a readable on mobile as it is on desktop I hope that this book serves as a faithful introduction to the Python language. Wherever necessary or beneficial to the reader, I will lean on references to sources in the vast body of work where other authors have shared their experise.","title":"About"},{"location":"about/#python-version","text":"Python version 3.10 is the target version for this text, however the majority of examples and language features discussed in the text are compatible with Python versions 3.6 or higher. Note that as of October 2022, Python 3.10 is the current stable release of the language, it is not the current defacto standard in use. That is to say that many widely used products have not adopted 3.10. For example, if you sign up for a free Google Colab account and begin authoring Python notebooks there, the Python version will likely be 3.8. When in doubt about language features, one can always reference the official documentation and select the correct version from the dropdown.","title":"Python Version"},{"location":"01/01-why-python/","text":"Why learn Python? \u00b6 You may already have an answer to this question. In this session we'll assume you still have doubts and attempt to answer the question \"Why should I learn Python?\". There are myriad reasons to learn Python that are different depending on your field of interest. There are various industry domains where Python shines (links available at the bottom of this page): web development information technology data science Within these industry sectors there are other options however. In data science for example R and SQL are both widely used languages. For web development, there are a host of other languages that can be used as web-backends: PHP , Node , and Java to name a few. Why learn Python? Any attempt to answer this absolutely is a foolish endeavour. There are, however, several strenghts of the Python language that make it a standout choice. Python is freely to download and use. Python runs on all major architectures and operating sytems. Python is a general purpose programming language. Python has a very clean and readable syntax. Python is popular! Simply listing these attributes of Python in a list may not be enough. The next few sections expand upon each. Python is freely available \u00b6 Python is open source and licensed in a manner that makes it agreeable with many coporate applications based on the language. Python can be used to create professional products without license fees or license requirements. You can read more about Python licenses on the History and License page of the official Python site. Python runs on all major Architectures \u00b6 Official Python installation packages are available for X86, ARM, and Apple M-series architecures for both Windows and macOS. Linux and UNIX packages are made available by package maintainers via the source releases made available on the official Python site. Python is general-purpose. \u00b6 If Python is specialized for anything, it is being a useful language in just about every computing domain. Python finds uses in everything from simple system adminstration tasks to full-fledged GUI applications. Given its popularity, there are many official and 3-rd party Python libraries that extend the language's use cases across a full spectrum of computing / development tasks. Create a web-app: Flask , FastAPI Download files from the web or query a web API: see Requests Administer remote machines: Fabric Data Engineering / Data Science: see examples on Kaggle Big-Data: see PySpark Python syntax is minimal and clean \u00b6 Syntax refers to the rules that define the structure of the language. Syntax rules specify the meaning of and relationships between symbols in the language. A clean language syntax makes that language easier to read. Quote Indeed, the ratio of time spent reading versus writing is well over 10 to 1. We are constantly reading old code as part of the effort to write new code. ...[Therefore,] making it easy to read makes it easier to write. Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship To illustrate the simplicity of Python syntax in comparison to other languages, consider grouping syntax . In C++ and Java for example, code is grouped using {} characters. The C++ source below illustrates this. bubble_sort.cpp void bubbleSort ( int array [], int size ) { // (1)! for ( int step = 0 ; step < size ; ++ step ) { // (2)! for ( int i = 0 ; i < size - step ; ++ i ) { if ( array [ i ] > array [ i + 1 ]) { int temp = array [ i ]; // (3)! array [ i ] = array [ i + 1 ]; array [ i + 1 ] = temp ; } } } } Curly braces {} group lines of code together. Note that indentation is also present. Complicated for loop step arguments. Semicolons ; must be present on all code statements. Compare the C++ code above to the equivalent Python implementation below. Note the absence of grouping characters. This is because the grouping syntax of Python relies on the indentation of the lines--not special characters that lead to visual clutter. bubble_sort.py def bubble_sort ( array ): for j in range ( len ( array )): # (1)! for k in range ( len ( array ) - j - 1 ): # (2)! if array [ k ] > array [ k + 1 ]: array [ k ], array [ k + 1 ] = array [ k + 1 ], array [ k ] # (3)! Simplified for loop expressions. Indentation is all that is needed to group code together. No semicolons ; are needed for any Python language statements. Some of Python's simplicity is owed to the simplicity of its built-in functions. Compare the two implementations of \"Hello World!\" below. C++ version: hello.cpp #include <iostream> int main () { std :: cout << \"Hello World!\" ; return 0 ; } Python version: hello.py print ( \"Hello World!\" ) The simplicity of the Python implementation is owed to the simplicity of the built-in print() function. In summary, Python's clean and readable syntax makes it easier to read and write the lanugage. It also reduces the number of potential syntax errors. Python is Popular \u00b6 As of October 2022, Python was number 1 on the TIOBE Index of programming languages. This index can be used to make a strategic decision about which language to learn. In short, Python is currently the most popular language in terms of usage according to the index. Popular languages bring with them many benefits: better security and stability (more contributors and financial support) more third-party libraries (get more done with less) supportive learning community (many available learning resources) Summary \u00b6 There is no reason to settle on learning only one programming language. However, in 2022, Python is an excellent choice. This still depends largely upon your target field. If this is your first venture into the world of software programming, Python's clean and readable syntax will allow you to learn more and at a faster pace. You're code will be simpler to write and troubleshoot. If your target field is data science/engineering, then Python is an excellent language to learn. Devoting time to learning Python language fundamentals will support your use of the many data science, machine learning, and modeling packages in widespread use.","title":"1. Why Python?"},{"location":"01/01-why-python/#why-learn-python","text":"You may already have an answer to this question. In this session we'll assume you still have doubts and attempt to answer the question \"Why should I learn Python?\". There are myriad reasons to learn Python that are different depending on your field of interest. There are various industry domains where Python shines (links available at the bottom of this page): web development information technology data science Within these industry sectors there are other options however. In data science for example R and SQL are both widely used languages. For web development, there are a host of other languages that can be used as web-backends: PHP , Node , and Java to name a few. Why learn Python? Any attempt to answer this absolutely is a foolish endeavour. There are, however, several strenghts of the Python language that make it a standout choice. Python is freely to download and use. Python runs on all major architectures and operating sytems. Python is a general purpose programming language. Python has a very clean and readable syntax. Python is popular! Simply listing these attributes of Python in a list may not be enough. The next few sections expand upon each.","title":"Why learn Python?"},{"location":"01/01-why-python/#python-is-freely-available","text":"Python is open source and licensed in a manner that makes it agreeable with many coporate applications based on the language. Python can be used to create professional products without license fees or license requirements. You can read more about Python licenses on the History and License page of the official Python site.","title":"Python is freely available"},{"location":"01/01-why-python/#python-runs-on-all-major-architectures","text":"Official Python installation packages are available for X86, ARM, and Apple M-series architecures for both Windows and macOS. Linux and UNIX packages are made available by package maintainers via the source releases made available on the official Python site.","title":"Python runs on all major Architectures"},{"location":"01/01-why-python/#python-is-general-purpose","text":"If Python is specialized for anything, it is being a useful language in just about every computing domain. Python finds uses in everything from simple system adminstration tasks to full-fledged GUI applications. Given its popularity, there are many official and 3-rd party Python libraries that extend the language's use cases across a full spectrum of computing / development tasks. Create a web-app: Flask , FastAPI Download files from the web or query a web API: see Requests Administer remote machines: Fabric Data Engineering / Data Science: see examples on Kaggle Big-Data: see PySpark","title":"Python is general-purpose."},{"location":"01/01-why-python/#python-syntax-is-minimal-and-clean","text":"Syntax refers to the rules that define the structure of the language. Syntax rules specify the meaning of and relationships between symbols in the language. A clean language syntax makes that language easier to read. Quote Indeed, the ratio of time spent reading versus writing is well over 10 to 1. We are constantly reading old code as part of the effort to write new code. ...[Therefore,] making it easy to read makes it easier to write. Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship To illustrate the simplicity of Python syntax in comparison to other languages, consider grouping syntax . In C++ and Java for example, code is grouped using {} characters. The C++ source below illustrates this. bubble_sort.cpp void bubbleSort ( int array [], int size ) { // (1)! for ( int step = 0 ; step < size ; ++ step ) { // (2)! for ( int i = 0 ; i < size - step ; ++ i ) { if ( array [ i ] > array [ i + 1 ]) { int temp = array [ i ]; // (3)! array [ i ] = array [ i + 1 ]; array [ i + 1 ] = temp ; } } } } Curly braces {} group lines of code together. Note that indentation is also present. Complicated for loop step arguments. Semicolons ; must be present on all code statements. Compare the C++ code above to the equivalent Python implementation below. Note the absence of grouping characters. This is because the grouping syntax of Python relies on the indentation of the lines--not special characters that lead to visual clutter. bubble_sort.py def bubble_sort ( array ): for j in range ( len ( array )): # (1)! for k in range ( len ( array ) - j - 1 ): # (2)! if array [ k ] > array [ k + 1 ]: array [ k ], array [ k + 1 ] = array [ k + 1 ], array [ k ] # (3)! Simplified for loop expressions. Indentation is all that is needed to group code together. No semicolons ; are needed for any Python language statements. Some of Python's simplicity is owed to the simplicity of its built-in functions. Compare the two implementations of \"Hello World!\" below. C++ version: hello.cpp #include <iostream> int main () { std :: cout << \"Hello World!\" ; return 0 ; } Python version: hello.py print ( \"Hello World!\" ) The simplicity of the Python implementation is owed to the simplicity of the built-in print() function. In summary, Python's clean and readable syntax makes it easier to read and write the lanugage. It also reduces the number of potential syntax errors.","title":"Python syntax is minimal and clean"},{"location":"01/01-why-python/#python-is-popular","text":"As of October 2022, Python was number 1 on the TIOBE Index of programming languages. This index can be used to make a strategic decision about which language to learn. In short, Python is currently the most popular language in terms of usage according to the index. Popular languages bring with them many benefits: better security and stability (more contributors and financial support) more third-party libraries (get more done with less) supportive learning community (many available learning resources)","title":"Python is Popular"},{"location":"01/01-why-python/#summary","text":"There is no reason to settle on learning only one programming language. However, in 2022, Python is an excellent choice. This still depends largely upon your target field. If this is your first venture into the world of software programming, Python's clean and readable syntax will allow you to learn more and at a faster pace. You're code will be simpler to write and troubleshoot. If your target field is data science/engineering, then Python is an excellent language to learn. Devoting time to learning Python language fundamentals will support your use of the many data science, machine learning, and modeling packages in widespread use.","title":"Summary"},{"location":"02/02-basic-types/","text":"Introduction \u00b6 In software programming data types are an important concept. Python programs can operate on a variety of types of data. Different types are handled differently in a Python program so it is important to understand the basic types that Python provides. Python data types fall into two categories: simple or atomic data types: can not be decomposed into a collection of another type non-atomic data types: are composed of other types Here each of the following types will be covered along with elementary operations that can be performed on them. Later chapters provide more detailed coverage and examples for each type. Built-in Atomic Types \u00b6 Python has the following bult-in atomic types: Text type: str Numeric types: int , float , complex Boolean type: bool None Type: NoneType Built-in Non-Atomic Types \u00b6 Sequences: list , tuple , range Mappings: dict Sets: set , frozenset Binary Types: bytes , bytearray Determining a Variable's Type \u00b6 There are two common methods to determine the type of a variable. When using the interactive Python shell, the type() function is the quickest way to check the type of a variable or a value returned from a function/operation. >>> type ( 'hello' ) str >>> type ( 100 ) int >>> type ( 100.100 ) float >>> type ( True ) bool If the type check is being performed in a program, it is often preferable to use the isinstance() function. This function operates a bit differently, but has the added benefit of returning a bool ( True or False ) value which can be used to programmatically determine how to handle the data in a program. >>> message = 'Assignment Complete!' >>> count = 200 >>> length = 10.5 >>> isinstance ( message , str ) True >>> isinstance ( count , int ) True >>> isinstance ( length , float ) True Type checks such as these are useful when we want to account for problems that occur at runtime or when we simply want to operate on differnt types in different ways. To summarize, use type() for interactive variable type checks and use isinstance() when checking the type in a program. Text Type: str \u00b6 Many other languages have multiple text types. In C++, for example, strings are non-atomic compositions of an atomic character type. Python differs in this regard. The only text type in Python is the str type. Note The bytes type is commonly used to store text that is transmitted over a communication interface, but this is not technically a text type. In fact, bytes objects must be decoded to convert them to strings. Literals and Variables \u00b6 A literal is an actual value of a certain type that is included in our code. String literals are entered as characters, surrounded by (delimited with) single or double quotes. The following simple program includes some string literal examples. string_examples.py country_code = 'CA' # (1)! product_code = \"EZ123\" # (2)! print ( country_code , product_code ) CA is a string literal. EZ123 is also a string literal. When we run this program, the following is printed to the screen. CA EZ123 To create a string variable, assign a string literal to a name using the assignment operator = . In the program above, country_code and product_code are both string variables because they have str types assigned to them. We can verify this save the code above to a Python module named string_examples.py and run it using IDLE . Type the following lines of code at the prompt in the Python shell. >>> type ( country_code ) str >>> isinstance ( product_code , str ) True The str() Function \u00b6 The str() function can be used to: create an empty string: str() with no arguments yields '' . convert a compatible type to a string. Example: str(5) yields \"5\" Basic Operations \u00b6 Some basic string operations include: concatenation repetition The following code sample demonstrates these to common string operations. string_examples.py first_name = \"Isaiah\" last_name = \"Thomas\" full_name = first_name + \" \" + last_name # (1)! border = \"#\" * 20 # (2)! print ( border ) print ( full_name ) print ( border ) Concatenation : The + operator is used to concatenate strings. Repetition : The * operator is used for string repetition. When string_examples.py above is run, the following is printed to the Python shell: string_examples.py output #################### Isaiah Thomas #################### Strings can be concatenated using the + operator. Note that this is both operands must be str types. The * is an interesting case where mixed types are allowed as operands. Repetition expressions are only allowed with str and int types. Attempting to use a float will result in an error. This completes a basic introduction to string types. More detail will be provided in later chapters. Numeric Types \u00b6 Python has three built-in atomic numeric types. This text focuses on int and float types. Type Description Literal Examples int Integer type 1 , -200 , 7_654_321 float Float type 1.11 , -200.0 , 1_234_567.8 complex Complex type 1 + 1j , 2.2 + 5j Literals and Variables \u00b6 Just as with str types, we need to be aware of how to enter literal values for numeric types. The table above provides examples literals for each numeric type. Creating a variable from any of these types is accomplished the same way as with strings. We use the assignment operator = . The following code assigns some numeric literals to names. When you run this code in IDLE , you can run type checks on the variables using the Python shell. numeric_examples.py product_count = 1000 product_weight = 22.3 Special Literal Formatting \u00b6 Python numeric types allow the use of underscores ( _ ) as thousands separators. This can be helpful with large values with many repeated digits. Python float types allow the use of standard exponential notation for representing very large and very small numbers. The following examples demonstrate these helpful formats. a_very_large_int = 1_000_000_000_000 a very_large_float = 1_000.000_123_123 one_thousand = 1e3 one_thousandth = 1E-3 The int() Function \u00b6 This function can be used to: create a zero-valued int . Example: int() yields 0 . convert a compatible type to an int type. Example: int(\"10\") yields an int 10 . The following example demonstrates a basic int conversion. Note that age_in_months could be defined initially as an int . It is defined first as a string here for demonstration purposes. numeric_examples.py MONTHS_PER_YEAR = 12 name = \"Phoenix\" age_in_months = \"12\" # convert age_in_months to a int age_in_months = int ( age_in_months ) age_in_years = age_in_months / MONTHS_PER_YEAR print ( f ' { name } is { age_in_months } months (or { age_in_years } years) old!' ) The float() function \u00b6 This function is used to: create a zero-valued float type. Example: float() yields 0.0 (a float type). convert a compatible type to float . Example: float(\"1.234\") yields 1.234 . Type Checks \u00b6 The Python shell session excerpt below demonstrates type checks on numeric types. The pattern is the same regardless of the type. We just supply the correct arguments to the type() and isinstance() functions. >>> type ( product_count ) int >>> type ( product_weight ) float >>> isinstance ( product_count , int ) True >>> isinstance ( product_weight , float ) True We will explore methods and operations with numeric types in the coming chapters. For now, we continue our survey of basic Python types with the Boolean type bool . Basic Operations \u00b6 Basic operations for numeric types were covered in the Use Python as a Calculator section. Operations on numeric types can have mixed numeric operands. For example we can add an int to a float . In such cases, the result type will be that of the type with higher precision-- float in the case of an int - float operation. Boolean Type: bool \u00b6 The boolean type bool is a special type in Python that is used for representing one of two values: True and False . These are a special type in Python because they can also be used in any expression where an int type is allowed. This is because the bool type is implemented as a subclass of int in Python. We know how to test this . >>> isinstance ( True , bool ) True >>> isinstance ( False , int ) True Literals and Variables \u00b6 The previous example demonstrated a few things. We can see bool literals True and False in the isinstance() checks. We also see that bool types are both int and bool . When a bool type is interpreted as an int , True is 1 and False is 0 . We can see this in action if we introduce a new function-- int() . >>> int ( True ) 1 >>> int ( False ) 0 Values of type bool can be assigned to a name just like any other type in Python. >>> product_in_stock = False >>> product_is_back_ordered = True We will see bool types again when we cover decision making in Python. The bool() Function \u00b6 This function is used to: create a False valued bool type. Example: bool() yields False . convert a compatible type to a bool type. bool(1) yields True . interpret a Python object as a boolean (True or False) The third bullet above requires a bit more explanation. In general, Python considers any 0 value to be False. Non-numeric types are interpreted differently. A zero-valued string, for example, has no characters. For built-in types, the value returned by the function associated with the type is considered as False. The following list has some example of boolean interpretation of non-numeric types. empty strings: False empty lists or tuples: False non-empty string, list, or tuple: True NoneType Type \u00b6 This is a special type in Python. More accurately, there is only one instance of this type stored in memory in a Python program as None . It is used to represent the absence of a value. This type is used as: default arguments in functions to check the return (or absence of a return) value from a function an explicit value returned form a function to signal information to the caller Caution Always use the is keyword when making comparisons to None . Example if name is None... . Sequence Types \u00b6 A Python sequence is an ordered collection of items which can be accessed by index number. The length of any sequence can be determined by passing it to the len() function which is introduced in this section. Note that str types are also sequence types. In addition to lists and tuples, string and bytes types are also sequences. This section focuses on: list type: list tuple type: tuple List Types \u00b6 A Python list is an ordered collection of Python objects. List can hold any type--even other lists. To define a list using a literal, surround a comma-separated list of object with square brackets: [ ] . list_examples.py nums = [ 1 , 2 , 3 ] # (1)! print ( type ( nums )) # (2)! print ( nums ) # (3)! len ( nums ) # (4)! The list literal here is a sequence of numbers, separated by commas and surrounded by a pair of square brackets. When inspecting type from a Python module, we need to use the print() function to actually see it in the shell output. We can use print() on lists to see a literal representation of the variable. Pass any sequence to the len() function to get the number of items stored. >>> list [1, 2, 3] 4 The list() Function \u00b6 As with other types, the list() function, called with no arguments, returns an empty list. When called with a compatible argument, the input argument is converted to a list. The following examples demonstrate. list_examples.py empty = list () # (1)! message = 'Hello' letters = list ( message ) # (2)! print ( empty ) print ( letters ) Calling list() with no arguments creates an empty list [] . Calling list() on a str type will create a list where each item is a single character from the source string. Running list_examples.py produces the following output in the console. [] ['H', 'e', 'l', 'l', 'o'] Inspecting Length \u00b6 The length of a sequence is equivalent to the number of items stored in the sequence. Pass a list (or any other sequence) to the len() function to see how many items are currently stored in the list. Accessing List Items \u00b6 There are multiple ways to access list items. The two most ways to access list items are by index and with list iteration in a for loop. List Items by Index \u00b6 The items in a sequence are stored in the order in which they were defined. An index value can be used to access each of the stored items. In Python, index values start from 0 . For the nums variable defined above, the indices are 0, 1, 2 . Note that nums stores 3 items. Since the index starts at 0 , the max index is actually len(nums) - 1 or 2. nums item value 1 2 3 index 0 1 2 When you access an item by index, the value is returned. This value can be used like any other value in Python. The following example demonstrates basic index access. list_examples.py city_state = [ 'Memphis' , 'TN' ] city = city_state [ 0 ] state = city_state [ 1 ] city_state_string = city + ',' + state print ( city_state_string ) When we run list_examples.py now, the following is output to the shell: Memphis, TN Lists in a for Loop \u00b6 Lists are commonly used to store similar items. Similar items are often processed similarly in a program. Python for loops provide an efficient way to access and process every item in a list. 1 2 3 4 5 nums = [ 1 , 2 , 3 ] for num in nums : # (1)! squared = num ** 2 print ( squared ) The membership expression num in nums will extract one element from nums and assign it to num on each loop run. The first line in the for loop (line 3) instructs the loop to: extract one item at a time from nums assign it to num run the loop body (lines 4-5). This process is referred to as iteration . Here, we are iterating over the items in nums . Python types that support iteration in this way are called iterables . Lists are iterables. List Item Assignment \u00b6 Python list types support item assignment . This means that we modify the items in a list. For example, if we want to shift all of the values in nums by a constant, we can do the following in a loop. Note that we make use of the range() function to get a sequence of index values. list_examples.py nums = [ 1 , 2 , 3 ] offset_value = 10 for k in range ( len ( nums )): # (1)! nums [ k ] = nums [ k ] + offset_value # (2)! print ( nums ) range(len(nums)) is the same as range(3) . This will provide the sequence 0, 1, 2 which is used in the loop to access the items by index. Here, one item is accessed by index per loop run. The offset_value is added to each and then assigned back to the list item. This is item assignment . Tuple Types \u00b6 The section on lists demonstrated a number of features of sequence types in Python. Sequence types support use of the len() function for determining length, indexing for accessing items. Sequence types also support iteration. Tuples are another sequence type that has these same features. Tuples are quite similar to lists. There are two differences: use ( ) instead of square brackets to define a tuple tuple type variables do not support item assignment. The following table provides a comparison of tuples and lists: feature list tuple index access len() iteration item assignment Tuples do not support item assignment. Attempting to change an item stored in a tuple will lead to an error. Try the following in the Python shell: Tuples do not support item assignment >>> nums = ( 1 , 2 , 3 ) # (1)! >>> nums [ 0 ] = 11 # (2)! TypeError Traceback (most recent call last) Input In [122], in <cell line: 1>() ----> 1 nums[0] = 11 TypeError: 'tuple' object does not support item assignment Create a tuple containing 1, 2, and 3. Attempt to assign 11 to the item at index 0 . Whenever you see a does not support item assignment error, it means that the data type you are using does not support item assignment: str and tuple are two such types. Tuples are Immutable \u00b6 Tuples do not support item assignment. This means that once a tuple is defined, it can not be modified. This is an essential feature of tuples called immutability. That is to say: tuples are immutable. This is very useful in programs where you need to pass data to functions with the assurance that the data will not be modified during the program run. Tuples are Lightweight \u00b6 Tuples require less program memory than lists making tuples a great data type to consider when optimizing a program for performance. The tuple() Function \u00b6 This function is used to: create an empty tuple . Note: this is not very useful accept for comparisons. convert a compatible type to tuple . Example: tuple('abc') yields ('a', 'b' 'c') Range Types \u00b6 Python's range() type is a type that has a very specific purpose--producing a uniform sequence of integers. Like tuples the range sequences are immutable. A range type object is created differently compared to other types in Python but they are indeed a sequence type. Literals and Variables \u00b6 Range types are created by calling the range() function with a list of arguments that specify the desired sequence range and step. The call signature for the range function is: range(stop) # or ... range(start, stop, [step]) There are a few different variations on calling range that we need to be aware of to use it with master: If called with stop only, range() will return a sequence 0, 1, 2, ..., stop-1 . Note that stop is not included in the sequence. If called with start and stop ( step is optional), then the sequence 1, 2, ..., stop-1 is returned. When called with all 3 parameters, the step argument is the interval between successive elements in the sequence. The following examples show a few example ranges: range ( 5 ) # (1)! # 0, 1, 2, 3, 4 range ( 1 , 5 ) # (2)! # 1, 2, 3, 4 range ( 1 , 5 , 2 ) # (3)! # 1, 3 range ( 0 , - 5 , - 1 ) # (4)! # 0, -1, -2, -3, -4 range ( - 1 , - 5 , - 2 ) # (5)! # 0, -2, -4 Calling range() with stop only results in a sequence that starts at 0. Specify start to start at a value other than 0. Specify the optional step argument to specify the interval between successive sequence elements. step can be negative. The results in descending order sequence. The stop argument is still not included in descending sequences. If you try to inspect a range type in the Python shell, you will see the function call needed to recreate the range object you are inspecting. In other words, the literal representation of a range type is the function call that creates it. Try running the following line in the Python shell: range ( 1 , 11 ) You should see the output range(1, 11) . Range objects can be assigned a names like any other type. Therefore the following works. We can even check the type like any other type. Try running the following lines one at a time in a shell to avoid the need to add print() calls. my_sequence = range ( 10 , 101 , 10 ) type ( my_sequence ) isinstance ( my_sequence , range ) The output when run from the shell is: >>> my_sequence = range ( 10 , 101 , 10 ) >>> type ( my_sequence ) range >>> isinstance ( my_sequence , range ) True Range Objects are Lazy \u00b6 Range objects do not immediately evaluate and return a sequence. This is why we see range(10, 101, 10) when we inspect the variable my_sequence above. Why is this so? Well, imagine you defined this range: range_examples.py big_range = range ( 10_000_000_000 ) # 10 billion integers print ( big_range ) Your computer would need to come up with enough free memory to store 10 billion integers--an estimated 40 GB. This is an unreasonable amount of space for a sequence that may only be used in a for loop. Range objects evaluate the next item in the sequence when it is needed (lazy iteration/evaluation). This way, you can loop through the range 0 to 10 billion without the memory overhead. We can coerce a range object into another sequence (eager evaluation) by using list () or tuple() . The following example demonstrates: my_sequence = list ( range ( 10 , 101 , 10 )) print ( my_sequence ) Which outputs: [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 ] Dictionary Types \u00b6 Mapping types are referred to as Dictionaries in the Python vernacular. In Python mappings are implemented by the dict type. Mappings map lookup keys to values in a one-to-one, directional relationship. This is similar to dictionaries used for language. When we look up a word in glossary or dictionary, we locate the definition. In this analogy, the words are keys and the definitions are values. We can create our own language dictionary using a dict in Python. Here, the definitions are shortened from the Oxford English Dictionary . dict_examples.py definitions = { 'tree' : 'a woody perennial plant.' , 'shrub' : 'a woody plant which is smaller than a tree' , 'bush' : 'a shrub or clump of shrubs' , 'hedge' : 'a fence or boundary formed by closely growing bushes or shrubs' } # Get the definition of tree tree_definition = definitions [ 'tree' ] print ( f 'tree: { tree_definition } ' ) This program outputs: >>> tree: a woody perennial plant. Literals and Values \u00b6 Define a dictionary in Python by enclosing a comma-separated list of key: value pairs with curly-braces {} . The following example maps country codes (keys) to country names (values). dictionary_examples.py codes_countries = { 'US' : 'United States' , 'IN' : 'India' } country = codes_countries [ 'IN' ] print ( f 'Code IN is for { country } ' ) Output: Code IN is for India The dict() Function \u00b6 This function is used to: create an empty dictionary. Example dict() yields {} . create a new dictionary from keyword arguments. See example below. This example uses the dict() function to define the codes_countries dictionary above. Try running this in a Python shell to see that it is equivalent to the previous example. dictionary_examples.py codes_countries = dict ( US = 'United States' , IN = 'India' ) # (1)! country = codes_countries [ 'IN' ] print ( f 'Code IN is for { country } ' ) Note that string keys to not need quotes when using the dict() function to define a dictionary. Dictionaries have a full chapter devoted to them where they are covered in more detail. We know turn our attention to Sets. Set Types \u00b6 Python sets are unordered collections of unique Python objects. Python sets are implemented by the set type. Set types can only store certain types. This type requires a good bit of additional discussion that is covered in a later chapter. For this gentle introduction to set types covers only built-in Python types that can be stored in a set. Sets are used to: remove duplicates from other types like lists and tuples. perform mathematical set operations like intersection and union. Literals and Values \u00b6 Define a set variable using a set literal which is a comma-separated sequence of objects enclosed in curly braces { } . The following example defines a set of words. Note that even though the word \"shrub\" is included twice, there is only one such value stored in the resulting set. woody_plants = { 'tree' , 'shrub' , 'bush' , 'hedge' , 'shrub' } print ( woody_plants ) Running this example results in the following output. Note that the order is not preserved. Sets are unordered collections. {'shrub', 'tree', 'hedge', 'bush'} Caution Sets and dictionaries both use curly braces { } as delimiters. The two can be easily distinguished from each other because set types do not contain any : . Note also that an empty dict literal is {} whereas an empty set literal is set() . The set() Function \u00b6 This function is used to: create an empty set type. Example: set() yields set() . create a set from another compatible type. Example set('abc') yields {'a', 'b','c'} . Style Notes \u00b6 PEP8 guidelines make several recommendations that apply to many of the types covered here. The following examples demonstrate how to follow these widely accepted guidelines. String Delimiters \u00b6 In Python, single and double quotes are equivalent. PEP8 makes no recommendation as to which one to use for string delimiters. Decide which one you prefer and use it consistently throughout a single codebase. 1 # WRONG: first_name = \"Jack\" last_name = 'Handy' # mixed quote types for strings # CORRECT: first_name = 'Jack' last_name = 'Handy' # pick one type and use it consistently Sequences \u00b6 Sequences of values or variables are used when defining lists, tuples, dictionaries, and sets. PEP8 makes a general recommendation that a space be included after any comma that is not at the end of a line. When defining these types, include these spaces.[^2] The following examples demonstrate: # WRONG: nums = [ 1 , 2 , 3 ] # CORRECT: nums = [ 1 , 2 , 3 ] # WRONG: codes_countries = { 'US' : 'United States' , 'IN' : 'India' } # CORRECT: codes_countries = { 'US' : 'United States' , 'IN' : 'India' } # WRONG: woody_plants = { 'tree' , 'shrub' , 'bush' , 'hedge' } # CORRECT: woody_plants = { 'tree' , 'shrub' , 'bush' , 'hedge' } Spaces After : \u00b6 When defining dictionaries, include a single space after every semicolon : . # WRONG: codes_countries = { 'US' : 'United States' , 'IN' : 'India' } # CORRECT: codes_countries = { 'US' : 'United States' , 'IN' : 'India' } Summary \u00b6 This concludes a rather broad survey of basic Python types. Each of these types receives detailed coverage in later chapters. Related Links \u00b6 Official Documentation - Built-in Types See PEP8 String Delimiters \u21a9","title":"Basic Types"},{"location":"02/02-basic-types/#introduction","text":"In software programming data types are an important concept. Python programs can operate on a variety of types of data. Different types are handled differently in a Python program so it is important to understand the basic types that Python provides. Python data types fall into two categories: simple or atomic data types: can not be decomposed into a collection of another type non-atomic data types: are composed of other types Here each of the following types will be covered along with elementary operations that can be performed on them. Later chapters provide more detailed coverage and examples for each type.","title":"Introduction"},{"location":"02/02-basic-types/#built-in-atomic-types","text":"Python has the following bult-in atomic types: Text type: str Numeric types: int , float , complex Boolean type: bool None Type: NoneType","title":"Built-in Atomic Types"},{"location":"02/02-basic-types/#built-in-non-atomic-types","text":"Sequences: list , tuple , range Mappings: dict Sets: set , frozenset Binary Types: bytes , bytearray","title":"Built-in Non-Atomic Types"},{"location":"02/02-basic-types/#determining-a-variables-type","text":"There are two common methods to determine the type of a variable. When using the interactive Python shell, the type() function is the quickest way to check the type of a variable or a value returned from a function/operation. >>> type ( 'hello' ) str >>> type ( 100 ) int >>> type ( 100.100 ) float >>> type ( True ) bool If the type check is being performed in a program, it is often preferable to use the isinstance() function. This function operates a bit differently, but has the added benefit of returning a bool ( True or False ) value which can be used to programmatically determine how to handle the data in a program. >>> message = 'Assignment Complete!' >>> count = 200 >>> length = 10.5 >>> isinstance ( message , str ) True >>> isinstance ( count , int ) True >>> isinstance ( length , float ) True Type checks such as these are useful when we want to account for problems that occur at runtime or when we simply want to operate on differnt types in different ways. To summarize, use type() for interactive variable type checks and use isinstance() when checking the type in a program.","title":"Determining a Variable's Type"},{"location":"02/02-basic-types/#text-type-str","text":"Many other languages have multiple text types. In C++, for example, strings are non-atomic compositions of an atomic character type. Python differs in this regard. The only text type in Python is the str type. Note The bytes type is commonly used to store text that is transmitted over a communication interface, but this is not technically a text type. In fact, bytes objects must be decoded to convert them to strings.","title":"Text Type: str"},{"location":"02/02-basic-types/#literals-and-variables","text":"A literal is an actual value of a certain type that is included in our code. String literals are entered as characters, surrounded by (delimited with) single or double quotes. The following simple program includes some string literal examples. string_examples.py country_code = 'CA' # (1)! product_code = \"EZ123\" # (2)! print ( country_code , product_code ) CA is a string literal. EZ123 is also a string literal. When we run this program, the following is printed to the screen. CA EZ123 To create a string variable, assign a string literal to a name using the assignment operator = . In the program above, country_code and product_code are both string variables because they have str types assigned to them. We can verify this save the code above to a Python module named string_examples.py and run it using IDLE . Type the following lines of code at the prompt in the Python shell. >>> type ( country_code ) str >>> isinstance ( product_code , str ) True","title":"Literals and Variables"},{"location":"02/02-basic-types/#the-str-function","text":"The str() function can be used to: create an empty string: str() with no arguments yields '' . convert a compatible type to a string. Example: str(5) yields \"5\"","title":"The str() Function"},{"location":"02/02-basic-types/#basic-operations","text":"Some basic string operations include: concatenation repetition The following code sample demonstrates these to common string operations. string_examples.py first_name = \"Isaiah\" last_name = \"Thomas\" full_name = first_name + \" \" + last_name # (1)! border = \"#\" * 20 # (2)! print ( border ) print ( full_name ) print ( border ) Concatenation : The + operator is used to concatenate strings. Repetition : The * operator is used for string repetition. When string_examples.py above is run, the following is printed to the Python shell: string_examples.py output #################### Isaiah Thomas #################### Strings can be concatenated using the + operator. Note that this is both operands must be str types. The * is an interesting case where mixed types are allowed as operands. Repetition expressions are only allowed with str and int types. Attempting to use a float will result in an error. This completes a basic introduction to string types. More detail will be provided in later chapters.","title":"Basic Operations"},{"location":"02/02-basic-types/#numeric-types","text":"Python has three built-in atomic numeric types. This text focuses on int and float types. Type Description Literal Examples int Integer type 1 , -200 , 7_654_321 float Float type 1.11 , -200.0 , 1_234_567.8 complex Complex type 1 + 1j , 2.2 + 5j","title":"Numeric Types"},{"location":"02/02-basic-types/#literals-and-variables_1","text":"Just as with str types, we need to be aware of how to enter literal values for numeric types. The table above provides examples literals for each numeric type. Creating a variable from any of these types is accomplished the same way as with strings. We use the assignment operator = . The following code assigns some numeric literals to names. When you run this code in IDLE , you can run type checks on the variables using the Python shell. numeric_examples.py product_count = 1000 product_weight = 22.3","title":"Literals and Variables"},{"location":"02/02-basic-types/#special-literal-formatting","text":"Python numeric types allow the use of underscores ( _ ) as thousands separators. This can be helpful with large values with many repeated digits. Python float types allow the use of standard exponential notation for representing very large and very small numbers. The following examples demonstrate these helpful formats. a_very_large_int = 1_000_000_000_000 a very_large_float = 1_000.000_123_123 one_thousand = 1e3 one_thousandth = 1E-3","title":"Special Literal Formatting"},{"location":"02/02-basic-types/#the-int-function","text":"This function can be used to: create a zero-valued int . Example: int() yields 0 . convert a compatible type to an int type. Example: int(\"10\") yields an int 10 . The following example demonstrates a basic int conversion. Note that age_in_months could be defined initially as an int . It is defined first as a string here for demonstration purposes. numeric_examples.py MONTHS_PER_YEAR = 12 name = \"Phoenix\" age_in_months = \"12\" # convert age_in_months to a int age_in_months = int ( age_in_months ) age_in_years = age_in_months / MONTHS_PER_YEAR print ( f ' { name } is { age_in_months } months (or { age_in_years } years) old!' )","title":"The int() Function"},{"location":"02/02-basic-types/#the-float-function","text":"This function is used to: create a zero-valued float type. Example: float() yields 0.0 (a float type). convert a compatible type to float . Example: float(\"1.234\") yields 1.234 .","title":"The float() function"},{"location":"02/02-basic-types/#type-checks","text":"The Python shell session excerpt below demonstrates type checks on numeric types. The pattern is the same regardless of the type. We just supply the correct arguments to the type() and isinstance() functions. >>> type ( product_count ) int >>> type ( product_weight ) float >>> isinstance ( product_count , int ) True >>> isinstance ( product_weight , float ) True We will explore methods and operations with numeric types in the coming chapters. For now, we continue our survey of basic Python types with the Boolean type bool .","title":"Type Checks"},{"location":"02/02-basic-types/#basic-operations_1","text":"Basic operations for numeric types were covered in the Use Python as a Calculator section. Operations on numeric types can have mixed numeric operands. For example we can add an int to a float . In such cases, the result type will be that of the type with higher precision-- float in the case of an int - float operation.","title":"Basic Operations"},{"location":"02/02-basic-types/#boolean-type-bool","text":"The boolean type bool is a special type in Python that is used for representing one of two values: True and False . These are a special type in Python because they can also be used in any expression where an int type is allowed. This is because the bool type is implemented as a subclass of int in Python. We know how to test this . >>> isinstance ( True , bool ) True >>> isinstance ( False , int ) True","title":"Boolean Type: bool"},{"location":"02/02-basic-types/#literals-and-variables_2","text":"The previous example demonstrated a few things. We can see bool literals True and False in the isinstance() checks. We also see that bool types are both int and bool . When a bool type is interpreted as an int , True is 1 and False is 0 . We can see this in action if we introduce a new function-- int() . >>> int ( True ) 1 >>> int ( False ) 0 Values of type bool can be assigned to a name just like any other type in Python. >>> product_in_stock = False >>> product_is_back_ordered = True We will see bool types again when we cover decision making in Python.","title":"Literals and Variables"},{"location":"02/02-basic-types/#the-bool-function","text":"This function is used to: create a False valued bool type. Example: bool() yields False . convert a compatible type to a bool type. bool(1) yields True . interpret a Python object as a boolean (True or False) The third bullet above requires a bit more explanation. In general, Python considers any 0 value to be False. Non-numeric types are interpreted differently. A zero-valued string, for example, has no characters. For built-in types, the value returned by the function associated with the type is considered as False. The following list has some example of boolean interpretation of non-numeric types. empty strings: False empty lists or tuples: False non-empty string, list, or tuple: True","title":"The bool() Function"},{"location":"02/02-basic-types/#nonetype-type","text":"This is a special type in Python. More accurately, there is only one instance of this type stored in memory in a Python program as None . It is used to represent the absence of a value. This type is used as: default arguments in functions to check the return (or absence of a return) value from a function an explicit value returned form a function to signal information to the caller Caution Always use the is keyword when making comparisons to None . Example if name is None... .","title":"NoneType Type"},{"location":"02/02-basic-types/#sequence-types","text":"A Python sequence is an ordered collection of items which can be accessed by index number. The length of any sequence can be determined by passing it to the len() function which is introduced in this section. Note that str types are also sequence types. In addition to lists and tuples, string and bytes types are also sequences. This section focuses on: list type: list tuple type: tuple","title":"Sequence Types"},{"location":"02/02-basic-types/#list-types","text":"A Python list is an ordered collection of Python objects. List can hold any type--even other lists. To define a list using a literal, surround a comma-separated list of object with square brackets: [ ] . list_examples.py nums = [ 1 , 2 , 3 ] # (1)! print ( type ( nums )) # (2)! print ( nums ) # (3)! len ( nums ) # (4)! The list literal here is a sequence of numbers, separated by commas and surrounded by a pair of square brackets. When inspecting type from a Python module, we need to use the print() function to actually see it in the shell output. We can use print() on lists to see a literal representation of the variable. Pass any sequence to the len() function to get the number of items stored. >>> list [1, 2, 3] 4","title":"List Types"},{"location":"02/02-basic-types/#the-list-function","text":"As with other types, the list() function, called with no arguments, returns an empty list. When called with a compatible argument, the input argument is converted to a list. The following examples demonstrate. list_examples.py empty = list () # (1)! message = 'Hello' letters = list ( message ) # (2)! print ( empty ) print ( letters ) Calling list() with no arguments creates an empty list [] . Calling list() on a str type will create a list where each item is a single character from the source string. Running list_examples.py produces the following output in the console. [] ['H', 'e', 'l', 'l', 'o']","title":"The list() Function"},{"location":"02/02-basic-types/#inspecting-length","text":"The length of a sequence is equivalent to the number of items stored in the sequence. Pass a list (or any other sequence) to the len() function to see how many items are currently stored in the list.","title":"Inspecting Length"},{"location":"02/02-basic-types/#accessing-list-items","text":"There are multiple ways to access list items. The two most ways to access list items are by index and with list iteration in a for loop.","title":"Accessing List Items"},{"location":"02/02-basic-types/#list-items-by-index","text":"The items in a sequence are stored in the order in which they were defined. An index value can be used to access each of the stored items. In Python, index values start from 0 . For the nums variable defined above, the indices are 0, 1, 2 . Note that nums stores 3 items. Since the index starts at 0 , the max index is actually len(nums) - 1 or 2. nums item value 1 2 3 index 0 1 2 When you access an item by index, the value is returned. This value can be used like any other value in Python. The following example demonstrates basic index access. list_examples.py city_state = [ 'Memphis' , 'TN' ] city = city_state [ 0 ] state = city_state [ 1 ] city_state_string = city + ',' + state print ( city_state_string ) When we run list_examples.py now, the following is output to the shell: Memphis, TN","title":"List Items by Index"},{"location":"02/02-basic-types/#lists-in-a-for-loop","text":"Lists are commonly used to store similar items. Similar items are often processed similarly in a program. Python for loops provide an efficient way to access and process every item in a list. 1 2 3 4 5 nums = [ 1 , 2 , 3 ] for num in nums : # (1)! squared = num ** 2 print ( squared ) The membership expression num in nums will extract one element from nums and assign it to num on each loop run. The first line in the for loop (line 3) instructs the loop to: extract one item at a time from nums assign it to num run the loop body (lines 4-5). This process is referred to as iteration . Here, we are iterating over the items in nums . Python types that support iteration in this way are called iterables . Lists are iterables.","title":"Lists in a for Loop"},{"location":"02/02-basic-types/#list-item-assignment","text":"Python list types support item assignment . This means that we modify the items in a list. For example, if we want to shift all of the values in nums by a constant, we can do the following in a loop. Note that we make use of the range() function to get a sequence of index values. list_examples.py nums = [ 1 , 2 , 3 ] offset_value = 10 for k in range ( len ( nums )): # (1)! nums [ k ] = nums [ k ] + offset_value # (2)! print ( nums ) range(len(nums)) is the same as range(3) . This will provide the sequence 0, 1, 2 which is used in the loop to access the items by index. Here, one item is accessed by index per loop run. The offset_value is added to each and then assigned back to the list item. This is item assignment .","title":"List Item Assignment"},{"location":"02/02-basic-types/#tuple-types","text":"The section on lists demonstrated a number of features of sequence types in Python. Sequence types support use of the len() function for determining length, indexing for accessing items. Sequence types also support iteration. Tuples are another sequence type that has these same features. Tuples are quite similar to lists. There are two differences: use ( ) instead of square brackets to define a tuple tuple type variables do not support item assignment. The following table provides a comparison of tuples and lists: feature list tuple index access len() iteration item assignment Tuples do not support item assignment. Attempting to change an item stored in a tuple will lead to an error. Try the following in the Python shell: Tuples do not support item assignment >>> nums = ( 1 , 2 , 3 ) # (1)! >>> nums [ 0 ] = 11 # (2)! TypeError Traceback (most recent call last) Input In [122], in <cell line: 1>() ----> 1 nums[0] = 11 TypeError: 'tuple' object does not support item assignment Create a tuple containing 1, 2, and 3. Attempt to assign 11 to the item at index 0 . Whenever you see a does not support item assignment error, it means that the data type you are using does not support item assignment: str and tuple are two such types.","title":"Tuple Types"},{"location":"02/02-basic-types/#tuples-are-immutable","text":"Tuples do not support item assignment. This means that once a tuple is defined, it can not be modified. This is an essential feature of tuples called immutability. That is to say: tuples are immutable. This is very useful in programs where you need to pass data to functions with the assurance that the data will not be modified during the program run.","title":"Tuples are Immutable"},{"location":"02/02-basic-types/#tuples-are-lightweight","text":"Tuples require less program memory than lists making tuples a great data type to consider when optimizing a program for performance.","title":"Tuples are Lightweight"},{"location":"02/02-basic-types/#the-tuple-function","text":"This function is used to: create an empty tuple . Note: this is not very useful accept for comparisons. convert a compatible type to tuple . Example: tuple('abc') yields ('a', 'b' 'c')","title":"The tuple() Function"},{"location":"02/02-basic-types/#range-types","text":"Python's range() type is a type that has a very specific purpose--producing a uniform sequence of integers. Like tuples the range sequences are immutable. A range type object is created differently compared to other types in Python but they are indeed a sequence type.","title":"Range Types"},{"location":"02/02-basic-types/#literals-and-variables_3","text":"Range types are created by calling the range() function with a list of arguments that specify the desired sequence range and step. The call signature for the range function is: range(stop) # or ... range(start, stop, [step]) There are a few different variations on calling range that we need to be aware of to use it with master: If called with stop only, range() will return a sequence 0, 1, 2, ..., stop-1 . Note that stop is not included in the sequence. If called with start and stop ( step is optional), then the sequence 1, 2, ..., stop-1 is returned. When called with all 3 parameters, the step argument is the interval between successive elements in the sequence. The following examples show a few example ranges: range ( 5 ) # (1)! # 0, 1, 2, 3, 4 range ( 1 , 5 ) # (2)! # 1, 2, 3, 4 range ( 1 , 5 , 2 ) # (3)! # 1, 3 range ( 0 , - 5 , - 1 ) # (4)! # 0, -1, -2, -3, -4 range ( - 1 , - 5 , - 2 ) # (5)! # 0, -2, -4 Calling range() with stop only results in a sequence that starts at 0. Specify start to start at a value other than 0. Specify the optional step argument to specify the interval between successive sequence elements. step can be negative. The results in descending order sequence. The stop argument is still not included in descending sequences. If you try to inspect a range type in the Python shell, you will see the function call needed to recreate the range object you are inspecting. In other words, the literal representation of a range type is the function call that creates it. Try running the following line in the Python shell: range ( 1 , 11 ) You should see the output range(1, 11) . Range objects can be assigned a names like any other type. Therefore the following works. We can even check the type like any other type. Try running the following lines one at a time in a shell to avoid the need to add print() calls. my_sequence = range ( 10 , 101 , 10 ) type ( my_sequence ) isinstance ( my_sequence , range ) The output when run from the shell is: >>> my_sequence = range ( 10 , 101 , 10 ) >>> type ( my_sequence ) range >>> isinstance ( my_sequence , range ) True","title":"Literals and Variables"},{"location":"02/02-basic-types/#range-objects-are-lazy","text":"Range objects do not immediately evaluate and return a sequence. This is why we see range(10, 101, 10) when we inspect the variable my_sequence above. Why is this so? Well, imagine you defined this range: range_examples.py big_range = range ( 10_000_000_000 ) # 10 billion integers print ( big_range ) Your computer would need to come up with enough free memory to store 10 billion integers--an estimated 40 GB. This is an unreasonable amount of space for a sequence that may only be used in a for loop. Range objects evaluate the next item in the sequence when it is needed (lazy iteration/evaluation). This way, you can loop through the range 0 to 10 billion without the memory overhead. We can coerce a range object into another sequence (eager evaluation) by using list () or tuple() . The following example demonstrates: my_sequence = list ( range ( 10 , 101 , 10 )) print ( my_sequence ) Which outputs: [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 ]","title":"Range Objects are Lazy"},{"location":"02/02-basic-types/#dictionary-types","text":"Mapping types are referred to as Dictionaries in the Python vernacular. In Python mappings are implemented by the dict type. Mappings map lookup keys to values in a one-to-one, directional relationship. This is similar to dictionaries used for language. When we look up a word in glossary or dictionary, we locate the definition. In this analogy, the words are keys and the definitions are values. We can create our own language dictionary using a dict in Python. Here, the definitions are shortened from the Oxford English Dictionary . dict_examples.py definitions = { 'tree' : 'a woody perennial plant.' , 'shrub' : 'a woody plant which is smaller than a tree' , 'bush' : 'a shrub or clump of shrubs' , 'hedge' : 'a fence or boundary formed by closely growing bushes or shrubs' } # Get the definition of tree tree_definition = definitions [ 'tree' ] print ( f 'tree: { tree_definition } ' ) This program outputs: >>> tree: a woody perennial plant.","title":"Dictionary Types"},{"location":"02/02-basic-types/#literals-and-values","text":"Define a dictionary in Python by enclosing a comma-separated list of key: value pairs with curly-braces {} . The following example maps country codes (keys) to country names (values). dictionary_examples.py codes_countries = { 'US' : 'United States' , 'IN' : 'India' } country = codes_countries [ 'IN' ] print ( f 'Code IN is for { country } ' ) Output: Code IN is for India","title":"Literals and Values"},{"location":"02/02-basic-types/#the-dict-function","text":"This function is used to: create an empty dictionary. Example dict() yields {} . create a new dictionary from keyword arguments. See example below. This example uses the dict() function to define the codes_countries dictionary above. Try running this in a Python shell to see that it is equivalent to the previous example. dictionary_examples.py codes_countries = dict ( US = 'United States' , IN = 'India' ) # (1)! country = codes_countries [ 'IN' ] print ( f 'Code IN is for { country } ' ) Note that string keys to not need quotes when using the dict() function to define a dictionary. Dictionaries have a full chapter devoted to them where they are covered in more detail. We know turn our attention to Sets.","title":"The dict() Function"},{"location":"02/02-basic-types/#set-types","text":"Python sets are unordered collections of unique Python objects. Python sets are implemented by the set type. Set types can only store certain types. This type requires a good bit of additional discussion that is covered in a later chapter. For this gentle introduction to set types covers only built-in Python types that can be stored in a set. Sets are used to: remove duplicates from other types like lists and tuples. perform mathematical set operations like intersection and union.","title":"Set Types"},{"location":"02/02-basic-types/#literals-and-values_1","text":"Define a set variable using a set literal which is a comma-separated sequence of objects enclosed in curly braces { } . The following example defines a set of words. Note that even though the word \"shrub\" is included twice, there is only one such value stored in the resulting set. woody_plants = { 'tree' , 'shrub' , 'bush' , 'hedge' , 'shrub' } print ( woody_plants ) Running this example results in the following output. Note that the order is not preserved. Sets are unordered collections. {'shrub', 'tree', 'hedge', 'bush'} Caution Sets and dictionaries both use curly braces { } as delimiters. The two can be easily distinguished from each other because set types do not contain any : . Note also that an empty dict literal is {} whereas an empty set literal is set() .","title":"Literals and Values"},{"location":"02/02-basic-types/#the-set-function","text":"This function is used to: create an empty set type. Example: set() yields set() . create a set from another compatible type. Example set('abc') yields {'a', 'b','c'} .","title":"The set() Function"},{"location":"02/02-basic-types/#style-notes","text":"PEP8 guidelines make several recommendations that apply to many of the types covered here. The following examples demonstrate how to follow these widely accepted guidelines.","title":"Style Notes"},{"location":"02/02-basic-types/#string-delimiters","text":"In Python, single and double quotes are equivalent. PEP8 makes no recommendation as to which one to use for string delimiters. Decide which one you prefer and use it consistently throughout a single codebase. 1 # WRONG: first_name = \"Jack\" last_name = 'Handy' # mixed quote types for strings # CORRECT: first_name = 'Jack' last_name = 'Handy' # pick one type and use it consistently","title":"String Delimiters"},{"location":"02/02-basic-types/#sequences","text":"Sequences of values or variables are used when defining lists, tuples, dictionaries, and sets. PEP8 makes a general recommendation that a space be included after any comma that is not at the end of a line. When defining these types, include these spaces.[^2] The following examples demonstrate: # WRONG: nums = [ 1 , 2 , 3 ] # CORRECT: nums = [ 1 , 2 , 3 ] # WRONG: codes_countries = { 'US' : 'United States' , 'IN' : 'India' } # CORRECT: codes_countries = { 'US' : 'United States' , 'IN' : 'India' } # WRONG: woody_plants = { 'tree' , 'shrub' , 'bush' , 'hedge' } # CORRECT: woody_plants = { 'tree' , 'shrub' , 'bush' , 'hedge' }","title":"Sequences"},{"location":"02/02-basic-types/#spaces-after","text":"When defining dictionaries, include a single space after every semicolon : . # WRONG: codes_countries = { 'US' : 'United States' , 'IN' : 'India' } # CORRECT: codes_countries = { 'US' : 'United States' , 'IN' : 'India' }","title":"Spaces After :"},{"location":"02/02-basic-types/#summary","text":"This concludes a rather broad survey of basic Python types. Each of these types receives detailed coverage in later chapters.","title":"Summary"},{"location":"02/02-basic-types/#related-links","text":"Official Documentation - Built-in Types See PEP8 String Delimiters \u21a9","title":"Related Links"},{"location":"02/02-essential-built-ins/","text":"Introduction \u00b6 Another important topic in the entries of a high-level survey of the Python language are built-in functions. Built-in functions are functions that are available to your Python without the import statements. Each of the following subsections provides a brief overview of the function covered. Some of these have been introduced in other sections of the text but are listed here for the sake of quick access and simple reference. enumerate() \u00b6 Pass any iterable to the enumerate() function, and it will return a lazy sequence of tuples containing a count (staring at 0) and values returned from iterating over the iterable. Note that enumerate() iterates lazily (only as needed) instead of returning all elements of the sequence. This is not typically a problem because enumerate is widely used when iterating over the target sequence passed to it. enumerate_example.py country_codes = [ 'IN' , 'NL' , 'US' ] for count , code in enumerate ( country_codes ): print ( count , code ) Running enumerate_example.py produces the following output in the Python shell. enumerate_example.py output 0 IN 1 NL 2 US We can coerce enumerate() into returning all items in the sequence by passing it to list or tuple . >>> # force enumerate to return all items >>> list ( enumerate ( country_codes )) [(0, 'IN'), (1, 'NL'), (2, 'US')] # a list of tuples is returned. Tip A great use case for enumerate is when looping over an iterable of unknown size. This may sound strange at first. File reading is a classic example of this. If we want to keep an index of each line in a file as we read the file, we can use enumerate() . len() \u00b6 Pass any container to the len() function, and it will return the number of items stored in the container. A container is any type in Python that stores an arbitrary number of items. This includes list , tuple , set , dict , str and more. An example may be required for use on dict types. >>> codes_countries = { 'US' : 'United States' , 'IN' : 'India' } >>> len ( code_countries ) 2 # (1)! len() returns the number of keys when called on a dict type.","title":"Essential Built-Ins"},{"location":"02/02-essential-built-ins/#introduction","text":"Another important topic in the entries of a high-level survey of the Python language are built-in functions. Built-in functions are functions that are available to your Python without the import statements. Each of the following subsections provides a brief overview of the function covered. Some of these have been introduced in other sections of the text but are listed here for the sake of quick access and simple reference.","title":"Introduction"},{"location":"02/02-essential-built-ins/#enumerate","text":"Pass any iterable to the enumerate() function, and it will return a lazy sequence of tuples containing a count (staring at 0) and values returned from iterating over the iterable. Note that enumerate() iterates lazily (only as needed) instead of returning all elements of the sequence. This is not typically a problem because enumerate is widely used when iterating over the target sequence passed to it. enumerate_example.py country_codes = [ 'IN' , 'NL' , 'US' ] for count , code in enumerate ( country_codes ): print ( count , code ) Running enumerate_example.py produces the following output in the Python shell. enumerate_example.py output 0 IN 1 NL 2 US We can coerce enumerate() into returning all items in the sequence by passing it to list or tuple . >>> # force enumerate to return all items >>> list ( enumerate ( country_codes )) [(0, 'IN'), (1, 'NL'), (2, 'US')] # a list of tuples is returned. Tip A great use case for enumerate is when looping over an iterable of unknown size. This may sound strange at first. File reading is a classic example of this. If we want to keep an index of each line in a file as we read the file, we can use enumerate() .","title":"enumerate()"},{"location":"02/02-essential-built-ins/#len","text":"Pass any container to the len() function, and it will return the number of items stored in the container. A container is any type in Python that stores an arbitrary number of items. This includes list , tuple , set , dict , str and more. An example may be required for use on dict types. >>> codes_countries = { 'US' : 'United States' , 'IN' : 'India' } >>> len ( code_countries ) 2 # (1)! len() returns the number of keys when called on a dict type.","title":"len()"},{"location":"02/02-handling-errors/","text":"Errors are Inevitable \u00b6 The previous section demonstrated some very simple Python code statements. Hopefully, you successfully replicated the examples. Once you get beyond simple statements you'll inevitably encounter errors. Be patient as this is common even for professionals with years of experience with the language. Quote A different error message! Finally some progress! 1 Errors: Two-types \u00b6 The two types of error messages that you'll encounter are syntax errors and runtime errors . Syntax errors result from the violations of the basic rules of Python structure whereas runtime errors are usually the result of mistakes in the program logic. Naturally, we want to correct errors. Of the two, syntax errors are the simplest to address. Syntax Errors \u00b6 Syntax errors are mistakes in the structure of the text of the Python source code. The print() function, for example is a Python function. When we use the print function, we type the name of the function, followed by ( followed by the expression to print, followed by ) . >>> print ( \"Look ma! No errors!\" ) Look ma ! No errors ! If we enter this code into the editor and leave out the last ) , we introduce a syntax violation. Different editors handles this in different ways. IDLE will not warn you about this until you attempt to run the code. Let us attempt this example in IDLE . enter the following code into an editor window in IDLE save the file to a suitable file name (example: errors.py ) run the module with \"Run -> Module\" (or ++F5++) print ( 5 + 2 When we enter this code in IDLE , we receive no indication of an error. When we run the module, however, IDLE displays an error dialog. IDLE presents an error dialog for syntax errors. When we dismiss the dialog, the location of the error is highlighted in the editor window.Note that the location of the highlight is not exact , but it does provide enough context to make the correction. IDLE highlights the location of syntax errors. Note Sometimes, a syntax error is highlighted on a different line from the actual location of the actual error. This can be misleading. A simple method in this case is to inspect both the highlighted line and the preceding line. Various editors handle syntax errors in different ways. For example, PyCharm will automatically add the closing ) when you enter ( , which is helpful in avoiding such errors. If we delete the closing paren while editing further, PyCharm will annotate the error with a red squiggle line along with a hover tooltip. PyCharm annotates syntax errors as we edit. Syntax Errors are Caught By a Linter \u00b6 Syntax errors are typically caught by a linter or similar program which inspects the code prior to the text being sent to the Python interpreter for execution. Many IDEs provide a way to customize the linter and even add additional linters to further inform the user as to potential syntax, style, or even logic errors prior to code execution. PyCharm for example provides a wealth of feedback including style error hints, syntax warnings, spell-checking and more--all of which are presented to the developer as they edit code. More Syntax Error Examples \u00b6 The following Python program will be used to demonstrate more examples of syntax errors. Using IDLE , add copy and paste this code into a new editor window and save the file as errors.py . We can then introduce deliberate errors and inspect the syntax errors displayed in error dialogs. errors.py def hello ( name ): # (1)! \"\"\"Prints 'Hello <name>' where name=<name>\"\"\" # (2)! print ( f 'Hello { name } ' ) # (3)! # (4)! if __name__ == '__main__' : # (5)! hello ( 'Mom' ) # (6)! This is a Python function signature--the first line in a function definition. The def keyword starts a function definition. The name hello is used to call the function. The formal parameter name is used to accept input to the function. The parameter list must be enclosed in () and finally a semicolon : ends the function signature. The triple-quoted string here is a docstring . Docstrings are useful for documentation but also provide users of the function with useful help as they are printed when calling help() a function. Docstrings should be enclosed in triple double quotes-- \"\"\" . This is the function body which happens to be a single line for this function. The function body must be indented, usually with a 4 space indent. Per PEP8 guidelines, leave two blank spaces after a function definition. This main selection block is useful for including lines of code that will run when the module is run as a script. Indented code below this line will be run when your module is run in IDLE for example. This indented line of code will execute when you run the module as a script (Run-Run Module in IDLE ). This is a call to the hello() function defined previously. Here are some errors to introduce on your own to explore the various types of errors one can encounter. In each case, introduce the error, run the module , inspect the error dialog, and then correct the error. Tip Configure IDLE to display line numbers: On the toolbar select \"Options -> Show Line Numbers\". This will demonstrate how syntax errors assist in locating some errors by including line numbers. Remove a semicolon from either the function signature or the if statement. Run the module, inspect, and correct the error. Remove one of { or } from the call print(f'Hello {name}') . What error is displayed? Remove a single quote ' from any of the string literals in the program. Remove the spaces before hello('Mom') . What error is produced. Syntax Error Summary \u00b6 Syntax errors are raised when we break the structural rules of the language. Our IDE will typically inform us of such errors and provide enough context clues to aid our corrections. Hopefully you tried out the additional syntax error examples. It is good to see these now, when you are not focused on another problem. Runtime Errors \u00b6 Runtime errors are another type of error that you will encounter as you develop software. As the name implies, runtime errors occur when your program is run--at execution time. The majority of runtime errors are raised by the Python interpreter in response to a broad scope of potential problems. The list below highlights a few of the sources of runtime errors: logic errors included in the code itself user errors: incorrect values to types fed to program via web or text interface timeouts or connection errors when one program is communicating with another (querying a web API with Python for example). For most newcomers to the language, logic errors are the most common source of runtime errors. Logic errors are a broad range of errors that we introduce into our program. For every type and feature of the language, there are a different set of logic errors we could introduce. Here, we explore some common runtime errors experienced by new Python developers. Name Errors \u00b6 A NameError is raised by the interpreter when our program attempts to access a name that has not been defined. A classic example of this occurs when we mistype a variable or function name. Python is a case-sensitive language so the names 'Hello' and 'hello' are different. Enter the following program into an editor window in IDLE and run it to explore how the Python interpreter handles such an error. errors.py def hello ( name ): \"\"\"Prints 'Hello <name>' where name=<name>\"\"\" print ( f 'Hello { name } ' ) if __name__ == '__main__' : Hello ( 'Mom' ) # (1)! This is the source of the error. Hello is not the same as hello and Hello is not defined anywhere in the module. When you run errors.py , the following error is displayed by the interpreter in the Python shell . >>> Traceback ( most recent call last ): # (1)! File \"/Users/forrest/tmp/errors.py\" , line 7 , in < module > # (2)! Hello ( 'Mom' ) NameError : name 'Hello' is not defined . Did you mean : 'hello' ? # (3)! >>> Traceback is the first line you'll see in a simple traceback such as this. A traceback traces a runtime error back to its source. There are often many such lines in a traceback. This provides the ability to trace the entire path of calls that produced the error. This line names the error that was raise (here a NameError ). Beginning with Python 3.10, helpful hints are also printed on this line. IDLE 's Python shell provides a way for you to go straight from the error to the file and line that produced it. Right click on a line with a line number in the traceback and select \"Goto File/Line\". This will take you directly to the location related to the line in the traceback. Again, there are often multiple references to source code in a given traceback, so this will definitely come in handy. Right-Click on a file or line number in a traceback. TypeError \u00b6 Type errors arise when an operation is applied to an object of the wrong type. A classic example is the following: >>> \"10\" + 5 Traceback ( most recent call last ): File \"<pyshell#0>\" , line 1 , in < module > \"10\" + 5 TypeError : can only concatenate str ( not \"int\" ) to str # (1)! Here's a TypeError in the wild. Translated, this means we must either convert \"10\" to 10 or 5 to \"5\" --depending the desired result. Type errors are common throughout all levels of Python development. Common examples include: calling a function with the wrong order or type of arguments. arithmetic operations on mixed and incompatible types ValueError \u00b6 If you attempt to pass a negative value to a function that expects only positive values, a value error will be raised. Classic examples that result in the raise of a ValueError are usually associated with the math library which is part of the Python standard library. Here are a couple of examples: >>> import math >>> math . sqrt ( - 42 ) # (1)! Traceback ( most recent call last ): File \"<pyshell#3>\" , line 1 , in < module > math . sqrt ( - 42 ) ValueError : math domain error # (2)! >>> math . log ( - 10 ) raceback ( most recent call last ): File \"<pyshell#5>\" , line 1 , in < module > math . log ( - 10 ) # (3)! ValueError : math domain error # (4)! In pure math, this would result in a complex number. Python's cmath library can handle such values, but not the math library. Here's that ValueError . math.sqrt only handles positive values. Again, this would result in a complex number (or undefined in some contexts) and the math lib does not handle such types. The ValueError here is again related to a domain error. math.log() handles only positive valued inputs. Other Errors \u00b6 Many of the errors listed below deserve a bit more context than is given at this stage of the book. If some of them don't make sense now, don't worry. Specific error types will be covered in more detail once a related topic is introduced. The list below highlights some of the most common runtime errors experienced. Error Class Reason ImportError There was an issue loading a module with the import statement IndexError Raised when a sequence subscript is out of range. KeyError Raised when a dictionary key is not found TypeError Raised when an operation is applied to the incorrect data type ValueError Raised when a operation for function receives the correct type but incorrect value. ZeroDivisionError Raised when an operation results in a division by zero More Complicated Tracebacks \u00b6 Many of the tracebacks that you encounter will reference multiple lines of code. It can take a bit of practice to get used to interpreting such errors. A simple example will help illustrate. def hello ( name ): # (1)! \"\"\"Prints 'Hello name'\"\"\" print ( f 'Hello { name } ' ) def decorate ( name ): # (2)! \"\"\"Decorates a name with + signs\"\"\" return '++' + name + '++' def decorative_hello ( name ): # (3) \"\"\"Prints 'Hello ++name++'.\"\"\" decorated = decorate ( name ) hello ( decorated ) if __name__ == '__main__' : hello ( 'Mom' ) # (4)! decorative_hello ( 5 ) # (5)! We've seen this function in a previous example. For a call hello('Mom') this prints Hello Mom . This function returns a string with ++ on either side of it. To accomplish this is uses the + operator to put the strings together an operation called concatenation. decorative_hello() uses the other two functions ( hello() and decorate() ) to print a decorated name. This call will not produce an error. If you refer back to the TypeError section, it may help you understand why this line throws an error. When we run the code above from IDLE , the following traceback is produced. At first glance we can already see that there is a bit more to digest in this error message im comparison to the others demonstrated on this page. The key to quickly resolving the source of the error is to start reading in the right place. The first line in the traceback provides a hint. The best way to read tracebacks is by starting at the bottom and working up--if needed. The last line of source code referenced in a traceback is where the error occurred. This doesn't mean that this is the source of the problem. In the case of our example, the source of the problem is at the very top of the program, but we gain insight into why the error occurred by looking at where the error occurred. In the case of this example, the first and last lines of code listed in the traceback are all we need to determine the fix. Start from the bottom of annotation on the traceback and click through each description for more information. Traceback ( most recent call last ): File \"/Users/forrest/tmp/errors.py\" , line 19 , in < module > decorative_hello ( 5 ) # (4)! File \"/Users/forrest/tmp/errors.py\" , line 13 , in decorative_hello decorated = decorate ( name ) # (3)! File \"/Users/forrest/tmp/errors.py\" , line 8 , in decorate return '++' + name + '++' # (2)! TypeError : can only concatenate str ( not \"int\" ) to str # (1)! This is the error type--a TypeError . This lets us know that an operation was performed on the incorrect type. In the lines above, we look for arithmetic operations and function calls. This is the operation that raised the TypeError . Here we have a string type ++ concatenated with the variable name . The result of that operation would then be added to the last string type ++ except the error was raised. This is is decorative_hello() calling decorate() to concatenate the name variable with ++ . This is the true source of the error. decorative_hello() calls decorate() which is the function where the error occurred. decorate() contains operations on strings but is ultimately called with a number which is why the error is raised. The most upvoted post on devRant. Via bakablah \u21a9","title":"Handling Errors"},{"location":"02/02-handling-errors/#errors-are-inevitable","text":"The previous section demonstrated some very simple Python code statements. Hopefully, you successfully replicated the examples. Once you get beyond simple statements you'll inevitably encounter errors. Be patient as this is common even for professionals with years of experience with the language. Quote A different error message! Finally some progress! 1","title":"Errors are Inevitable"},{"location":"02/02-handling-errors/#errors-two-types","text":"The two types of error messages that you'll encounter are syntax errors and runtime errors . Syntax errors result from the violations of the basic rules of Python structure whereas runtime errors are usually the result of mistakes in the program logic. Naturally, we want to correct errors. Of the two, syntax errors are the simplest to address.","title":"Errors: Two-types"},{"location":"02/02-handling-errors/#syntax-errors","text":"Syntax errors are mistakes in the structure of the text of the Python source code. The print() function, for example is a Python function. When we use the print function, we type the name of the function, followed by ( followed by the expression to print, followed by ) . >>> print ( \"Look ma! No errors!\" ) Look ma ! No errors ! If we enter this code into the editor and leave out the last ) , we introduce a syntax violation. Different editors handles this in different ways. IDLE will not warn you about this until you attempt to run the code. Let us attempt this example in IDLE . enter the following code into an editor window in IDLE save the file to a suitable file name (example: errors.py ) run the module with \"Run -> Module\" (or ++F5++) print ( 5 + 2 When we enter this code in IDLE , we receive no indication of an error. When we run the module, however, IDLE displays an error dialog. IDLE presents an error dialog for syntax errors. When we dismiss the dialog, the location of the error is highlighted in the editor window.Note that the location of the highlight is not exact , but it does provide enough context to make the correction. IDLE highlights the location of syntax errors. Note Sometimes, a syntax error is highlighted on a different line from the actual location of the actual error. This can be misleading. A simple method in this case is to inspect both the highlighted line and the preceding line. Various editors handle syntax errors in different ways. For example, PyCharm will automatically add the closing ) when you enter ( , which is helpful in avoiding such errors. If we delete the closing paren while editing further, PyCharm will annotate the error with a red squiggle line along with a hover tooltip. PyCharm annotates syntax errors as we edit.","title":"Syntax Errors"},{"location":"02/02-handling-errors/#syntax-errors-are-caught-by-a-linter","text":"Syntax errors are typically caught by a linter or similar program which inspects the code prior to the text being sent to the Python interpreter for execution. Many IDEs provide a way to customize the linter and even add additional linters to further inform the user as to potential syntax, style, or even logic errors prior to code execution. PyCharm for example provides a wealth of feedback including style error hints, syntax warnings, spell-checking and more--all of which are presented to the developer as they edit code.","title":"Syntax Errors are Caught By a Linter"},{"location":"02/02-handling-errors/#more-syntax-error-examples","text":"The following Python program will be used to demonstrate more examples of syntax errors. Using IDLE , add copy and paste this code into a new editor window and save the file as errors.py . We can then introduce deliberate errors and inspect the syntax errors displayed in error dialogs. errors.py def hello ( name ): # (1)! \"\"\"Prints 'Hello <name>' where name=<name>\"\"\" # (2)! print ( f 'Hello { name } ' ) # (3)! # (4)! if __name__ == '__main__' : # (5)! hello ( 'Mom' ) # (6)! This is a Python function signature--the first line in a function definition. The def keyword starts a function definition. The name hello is used to call the function. The formal parameter name is used to accept input to the function. The parameter list must be enclosed in () and finally a semicolon : ends the function signature. The triple-quoted string here is a docstring . Docstrings are useful for documentation but also provide users of the function with useful help as they are printed when calling help() a function. Docstrings should be enclosed in triple double quotes-- \"\"\" . This is the function body which happens to be a single line for this function. The function body must be indented, usually with a 4 space indent. Per PEP8 guidelines, leave two blank spaces after a function definition. This main selection block is useful for including lines of code that will run when the module is run as a script. Indented code below this line will be run when your module is run in IDLE for example. This indented line of code will execute when you run the module as a script (Run-Run Module in IDLE ). This is a call to the hello() function defined previously. Here are some errors to introduce on your own to explore the various types of errors one can encounter. In each case, introduce the error, run the module , inspect the error dialog, and then correct the error. Tip Configure IDLE to display line numbers: On the toolbar select \"Options -> Show Line Numbers\". This will demonstrate how syntax errors assist in locating some errors by including line numbers. Remove a semicolon from either the function signature or the if statement. Run the module, inspect, and correct the error. Remove one of { or } from the call print(f'Hello {name}') . What error is displayed? Remove a single quote ' from any of the string literals in the program. Remove the spaces before hello('Mom') . What error is produced.","title":"More Syntax Error Examples"},{"location":"02/02-handling-errors/#syntax-error-summary","text":"Syntax errors are raised when we break the structural rules of the language. Our IDE will typically inform us of such errors and provide enough context clues to aid our corrections. Hopefully you tried out the additional syntax error examples. It is good to see these now, when you are not focused on another problem.","title":"Syntax Error Summary"},{"location":"02/02-handling-errors/#runtime-errors","text":"Runtime errors are another type of error that you will encounter as you develop software. As the name implies, runtime errors occur when your program is run--at execution time. The majority of runtime errors are raised by the Python interpreter in response to a broad scope of potential problems. The list below highlights a few of the sources of runtime errors: logic errors included in the code itself user errors: incorrect values to types fed to program via web or text interface timeouts or connection errors when one program is communicating with another (querying a web API with Python for example). For most newcomers to the language, logic errors are the most common source of runtime errors. Logic errors are a broad range of errors that we introduce into our program. For every type and feature of the language, there are a different set of logic errors we could introduce. Here, we explore some common runtime errors experienced by new Python developers.","title":"Runtime Errors"},{"location":"02/02-handling-errors/#name-errors","text":"A NameError is raised by the interpreter when our program attempts to access a name that has not been defined. A classic example of this occurs when we mistype a variable or function name. Python is a case-sensitive language so the names 'Hello' and 'hello' are different. Enter the following program into an editor window in IDLE and run it to explore how the Python interpreter handles such an error. errors.py def hello ( name ): \"\"\"Prints 'Hello <name>' where name=<name>\"\"\" print ( f 'Hello { name } ' ) if __name__ == '__main__' : Hello ( 'Mom' ) # (1)! This is the source of the error. Hello is not the same as hello and Hello is not defined anywhere in the module. When you run errors.py , the following error is displayed by the interpreter in the Python shell . >>> Traceback ( most recent call last ): # (1)! File \"/Users/forrest/tmp/errors.py\" , line 7 , in < module > # (2)! Hello ( 'Mom' ) NameError : name 'Hello' is not defined . Did you mean : 'hello' ? # (3)! >>> Traceback is the first line you'll see in a simple traceback such as this. A traceback traces a runtime error back to its source. There are often many such lines in a traceback. This provides the ability to trace the entire path of calls that produced the error. This line names the error that was raise (here a NameError ). Beginning with Python 3.10, helpful hints are also printed on this line. IDLE 's Python shell provides a way for you to go straight from the error to the file and line that produced it. Right click on a line with a line number in the traceback and select \"Goto File/Line\". This will take you directly to the location related to the line in the traceback. Again, there are often multiple references to source code in a given traceback, so this will definitely come in handy. Right-Click on a file or line number in a traceback.","title":"Name Errors"},{"location":"02/02-handling-errors/#typeerror","text":"Type errors arise when an operation is applied to an object of the wrong type. A classic example is the following: >>> \"10\" + 5 Traceback ( most recent call last ): File \"<pyshell#0>\" , line 1 , in < module > \"10\" + 5 TypeError : can only concatenate str ( not \"int\" ) to str # (1)! Here's a TypeError in the wild. Translated, this means we must either convert \"10\" to 10 or 5 to \"5\" --depending the desired result. Type errors are common throughout all levels of Python development. Common examples include: calling a function with the wrong order or type of arguments. arithmetic operations on mixed and incompatible types","title":"TypeError"},{"location":"02/02-handling-errors/#valueerror","text":"If you attempt to pass a negative value to a function that expects only positive values, a value error will be raised. Classic examples that result in the raise of a ValueError are usually associated with the math library which is part of the Python standard library. Here are a couple of examples: >>> import math >>> math . sqrt ( - 42 ) # (1)! Traceback ( most recent call last ): File \"<pyshell#3>\" , line 1 , in < module > math . sqrt ( - 42 ) ValueError : math domain error # (2)! >>> math . log ( - 10 ) raceback ( most recent call last ): File \"<pyshell#5>\" , line 1 , in < module > math . log ( - 10 ) # (3)! ValueError : math domain error # (4)! In pure math, this would result in a complex number. Python's cmath library can handle such values, but not the math library. Here's that ValueError . math.sqrt only handles positive values. Again, this would result in a complex number (or undefined in some contexts) and the math lib does not handle such types. The ValueError here is again related to a domain error. math.log() handles only positive valued inputs.","title":"ValueError"},{"location":"02/02-handling-errors/#other-errors","text":"Many of the errors listed below deserve a bit more context than is given at this stage of the book. If some of them don't make sense now, don't worry. Specific error types will be covered in more detail once a related topic is introduced. The list below highlights some of the most common runtime errors experienced. Error Class Reason ImportError There was an issue loading a module with the import statement IndexError Raised when a sequence subscript is out of range. KeyError Raised when a dictionary key is not found TypeError Raised when an operation is applied to the incorrect data type ValueError Raised when a operation for function receives the correct type but incorrect value. ZeroDivisionError Raised when an operation results in a division by zero","title":"Other Errors"},{"location":"02/02-handling-errors/#more-complicated-tracebacks","text":"Many of the tracebacks that you encounter will reference multiple lines of code. It can take a bit of practice to get used to interpreting such errors. A simple example will help illustrate. def hello ( name ): # (1)! \"\"\"Prints 'Hello name'\"\"\" print ( f 'Hello { name } ' ) def decorate ( name ): # (2)! \"\"\"Decorates a name with + signs\"\"\" return '++' + name + '++' def decorative_hello ( name ): # (3) \"\"\"Prints 'Hello ++name++'.\"\"\" decorated = decorate ( name ) hello ( decorated ) if __name__ == '__main__' : hello ( 'Mom' ) # (4)! decorative_hello ( 5 ) # (5)! We've seen this function in a previous example. For a call hello('Mom') this prints Hello Mom . This function returns a string with ++ on either side of it. To accomplish this is uses the + operator to put the strings together an operation called concatenation. decorative_hello() uses the other two functions ( hello() and decorate() ) to print a decorated name. This call will not produce an error. If you refer back to the TypeError section, it may help you understand why this line throws an error. When we run the code above from IDLE , the following traceback is produced. At first glance we can already see that there is a bit more to digest in this error message im comparison to the others demonstrated on this page. The key to quickly resolving the source of the error is to start reading in the right place. The first line in the traceback provides a hint. The best way to read tracebacks is by starting at the bottom and working up--if needed. The last line of source code referenced in a traceback is where the error occurred. This doesn't mean that this is the source of the problem. In the case of our example, the source of the problem is at the very top of the program, but we gain insight into why the error occurred by looking at where the error occurred. In the case of this example, the first and last lines of code listed in the traceback are all we need to determine the fix. Start from the bottom of annotation on the traceback and click through each description for more information. Traceback ( most recent call last ): File \"/Users/forrest/tmp/errors.py\" , line 19 , in < module > decorative_hello ( 5 ) # (4)! File \"/Users/forrest/tmp/errors.py\" , line 13 , in decorative_hello decorated = decorate ( name ) # (3)! File \"/Users/forrest/tmp/errors.py\" , line 8 , in decorate return '++' + name + '++' # (2)! TypeError : can only concatenate str ( not \"int\" ) to str # (1)! This is the error type--a TypeError . This lets us know that an operation was performed on the incorrect type. In the lines above, we look for arithmetic operations and function calls. This is the operation that raised the TypeError . Here we have a string type ++ concatenated with the variable name . The result of that operation would then be added to the last string type ++ except the error was raised. This is is decorative_hello() calling decorate() to concatenate the name variable with ++ . This is the true source of the error. decorative_hello() calls decorate() which is the function where the error occurred. decorate() contains operations on strings but is ultimately called with a number which is why the error is raised. The most upvoted post on devRant. Via bakablah \u21a9","title":"More Complicated Tracebacks"},{"location":"02/02-python-typing/","text":"Python is Strongly Typed \u00b6 Types are important in Python as different types have different \"behaviors\". For example, we cannot UPPERCASE and int type. We cannot add a string type to an integer type because Python doesn't automatically convert one type to another to perform such operations. In weakly typed languages like Javascript, an operation like \"100\" - 1 yields the result 99 . However, Python raises a TypeError for the same operation. In this example, Javascript is being \"smart\" and Python is apparently being \"strict\". Consider the example \"100\" + 1 . In Javascript, the result is \"1001\" . If types are important, then why aren't types explicit? That is to say, why aren't types included when we define a variable? This is because Python is a dynamically typed language. This means that the type of a variable is determined when the program is run--not when the source code is read by the interpreter. Note You will see types included in modern Python code. These are referred to as \"type hints\" and are used by development tools for code quality assurance. Type hints do not force Python to use a specific type.","title":"Python Typing"},{"location":"02/02-python-typing/#python-is-strongly-typed","text":"Types are important in Python as different types have different \"behaviors\". For example, we cannot UPPERCASE and int type. We cannot add a string type to an integer type because Python doesn't automatically convert one type to another to perform such operations. In weakly typed languages like Javascript, an operation like \"100\" - 1 yields the result 99 . However, Python raises a TypeError for the same operation. In this example, Javascript is being \"smart\" and Python is apparently being \"strict\". Consider the example \"100\" + 1 . In Javascript, the result is \"1001\" . If types are important, then why aren't types explicit? That is to say, why aren't types included when we define a variable? This is because Python is a dynamically typed language. This means that the type of a variable is determined when the program is run--not when the source code is read by the interpreter. Note You will see types included in modern Python code. These are referred to as \"type hints\" and are used by development tools for code quality assurance. Type hints do not force Python to use a specific type.","title":"Python is Strongly Typed"},{"location":"02/02-setting-up-python/","text":"Downloading Python \u00b6 The Python version supported by this text is version 3.10.x (note that the x can be any number). When downloading Python, please be sure to select this version. Official Python releases are available from the official Python Page . The site auto detects your operating system and provides a link to the most current version. If the target version is not listed, you can visit the All Releases page to locate it. Installing Python \u00b6 For installation instructions, I will lean on the expertise of the RealPython team. This platform maintains up-to-date, community reviewed instuctions and articles on many Python related topics. Visit the RealPython installation instructions for an up-to-date guide on installing for your operating system and platform. For Windows Users... Do not install the Microsoft Store version of Python. Be sure to install the package available from the official Python page. Using the IDLE IDE \u00b6 An IDE (intgrated development environment) typically includes: an editor for editing code a method for building / running code a debugger for tracing program execution and troubleshooting errors Python programs are simply text files, so you can technically use your preferred plain text editor to edit Python code. However, you will need to rely on the operating system shell / terminal to run your code using the Python interpreter. An IDE simplifies your workflow when editing and running programs. For first time Python users, IDLE is a great choice for many reasons: IDLE is installed when you install Python using the official installer. IDLE is preconfigured and ready to use for Python development. IDLE is simpler than most IDEs. This text will refer only to IDLE when showing examples that involve an IDE. Launching IDLE \u00b6 Launch IDLE using your favorite launch method. On most operating systems, the search feature is typically the fastest. On Windows, press the Windows key and start typing IDLE On macOS, type Command + SPACE and start typing IDLE When IDLE launches, you will be greeted by a window containing the Python shell. We'll refer to this as the \"shell window\" or \"interactive window\". The interactive window lets you interact with the Python interpreter directly by entering code statements and viewing the result. Python Shell / IDLE Interactive Window Introducing the Python Shell \u00b6 The default Python shell provides a simple Read-Evaluate-Print-Loop ( REPL ) interface to the Python interpreter. You are greeted with the Python shell when you start IDLE or launch the shell directly from an OS shell. Take a moment to explore the basic parts of the Python shell using the annotations below. Python 3.10.0 ( v3 .10.0 : b494f5935c , Oct 4 2021 , 14 : 59 : 19 ) [ Clang 12.0.5 ( clang - 1205.0.22.11 )] on darwin # (1)! Type \"help\" , \"copyright\" , \"credits\" or \"license()\" for more information . # (2)! >>> # (3)! >>> print ( 'Hello World!' ) # (4)! Hello World # (5)! >>> The Python version (here, 3.10.0) is shown at the beginning of a Python shell session. Don't overlook help here. Python's help feature is, well, helpful. The >>> shown here is the Python shell prompt. Never enter these characters explicitly when pasting example code. Enter a single line of Python code like this one. When you press +Enter+, the Python interpreter reads and evaluates the code. It then prints the result. The Python interpreter prints the result. Note the absences of the >>> prompt on the result line. Note The term \"shell\" is more commonly used to refer to an operating system command line interface such as CMD.exe on Windows or Terminal.app on macOS. \"Python shell\" will be used whenever referring to Python. Use Python as a Calculator \u00b6 You can use the Python shell as a simple calculator. Python arithmetic expressions use the following operators. example operation result mathematical operation 2 + 5 7 addition 2 - 5 -3 subtraction 5 / 2 2.5 float division 5 * 2 10 multiplication 2 ** 5 32 exponentiation 5 // 2 2 integer division 5 % 2 1 modulus operator When you enter one of these expression at the Python shell prompt the result will be printed below the prompt. Add Some Variables \u00b6 Variables are names (symbols) that refer to a value. In order to use a variable, a value must be assigned to it using the assignment operator = . Experimemnt with this a bit using single character variable names. x = 5 # (1)! y = 2 # (2)! x + y # (3)! The symbol (name) x now refers to the value 5 . The symbol y now refers to the value `2. In evaluating this expression, the Python interpreter retrieves the values referred to by the names ( x and y ) before evaluating the arithmetic expression. Rules for Names in Python \u00b6 The rules for names in Python are simple, yet important. One common pitfall is forgetting that names are case sensitive in Python. This means that height and Height are different names in Python. A variable name must start with a letter or the underscore character ( _ ) A variable name cannot start with a number A variable name can only contain alpha-numeric characters and underscores ( A-Z , a-z , 0-9 , and _ ). Variable names are case-sensitive ( age , Age and AGE are three different variables) Keyboard Shortcuts in the Shell \u00b6 shortcut operation Ctrl + P previous history Ctrl + N next history Ctrl + A beginning of line Ctrl + E end of line It is also worth noting that the previous result is always stored in the varaible _ . You can access this instead of copying and pasting a result. Example shell session: >>> x = 5 >>> y = 2 >>> x + y 7 >>> _ + 10 # (1)! 17 _ is a special Python shell variable that stores the result of the last expression evaluated by the interpreter. Use this instead of copying and pasting. The Editor Window \u00b6 The Python shell is an essential development tool for quickly prototyping ideas. In a typical software development workflow, use of the Python shell is typically short-lived because we need our code to reside in a place where it can be re-used--in a file. We use the IDLE editor window for this. Files that contain Python code are referred to as Python scripts , modules , or simply Python files. script : a file containing Python code that is meant to be run directly--like a standalone program/application. module : A module is a file containing Python code that can be imported by other Python scripts or modules. ( Note that Python modules can also be run directly. ) Edit and Run a New Python Module \u00b6 When IDLE launches, only the Python shell window is displayed for use. You can open an editor window by selecting File -> New File . Try this now and enter the following calculator code into the resulting window. x = 5 y = 2 x + y You'll need to save this file with a Python extension .py before you can run it. Choose File -> Save (or Ctrl + S on , Cmd + S on ) Choose a file location and save the file as calculate.py . Now that you have saved the file, you can run the file using Run -> Run Module . Note that there is a keyboard shortcut for this as well --( F5 ) If you entered the exact code above in the file, you'll notice that there is no output when you run the module. This is one key difference between the editor and the Python shell. The Python shell always displays the result of an expression . When we run a module, the result of every expression is not printed to the screen. In order to view the results of expressions, we must use the print() function. Modify your code to include the modifications shown below: x = 5 y = 2 print ( x + y ) # (1)! Use print to display the result of (or value of) an expression. Edit and Run an Existing Python Module \u00b6 In IDLE , use FILE -> Open From the file browser, right-click the file and choose Open with IDLE Danger Double-clicking a Python file in the file browser will cause the module to be executed in the background. Learn Python with IDLE \u00b6 As you progress through the course, you will encounter many new language features. You can accelerate your learning by interacting with these features as soon as you encounter them. Use the Python shell to quickly try out Python code snippets found in this text. When code snippets begin to evolve into something you want to experiment with a bit more, use the editor to maintain the code in an editable file which you can run again and again. Here are some tips for learning with IDLE : Keep IDLE open while working through this text. Click the copy to clipboard icon next to any code in this text to copy the code. Paste the code into the Python shell to quickly view a result. Re-paste the code and make some modifications. Collect code snippets in a Python module for further modifications recall that you need to add print() to print any results that are not already printed. Other IDEs \u00b6 It is highly recommended that you use IDLE initially if you are a just getting started with the Python language. IDLE is installed when you install Python from the offical Python site . Moreover, IDLE requires no additional configuration and its minimal interface keeps the focus on the language. As you become more comfortable with the language, you'll inevitably long for a more feature rich environment for developing Python code. Microsoft Visual Studio Code \u00b6 Visual Studio Code is a widely used IDE. VS Code is has strong support for Python via extensions. Visit the Real Python article on setting up VS Code for Python development. Thoughts on VS Code: VS Code requires a bit of configuration before it is in a usable state for Python development. VS Code is freely available and runs on most platforms. Pycharm \u00b6 Pycharm is a JetBrains product. The education version is free, but you will need to verify student status--the process is simple and worth it. Visit the RealPython article on using PyCharm for development. Note PyCharm is a highly recommended IDE. Give it a try once you have some minimal experience programming Python with IDLE . PyCharm educational licenses are quite easy to obtain. Be sure to get the educational version (not the community edition). PyCharm integrates well with all Python environments and GitHub. It also supports notebooks. All of this comes with very minimal configuration compared to Jupyter and VS Code. Thoughts on PyCharm: PyCharm requires much less configuration compared to VS Code PyCharm is designed as a Python first IDE, so it is ready for Python development. PyCharm feels like more of a professional product compared to VS Code. This is, of course, subjective. PyCharm runs on Windows or macOS. Jupyter Notebooks \u00b6 Jupyter Notebooks are a great way to develop Python. Jupyter Notebooks provide a browser based editing environment for Python. In a notebook, code is entered into \"cells\". Cells can be evaluated any number of times and the result is printed below the cell. Notebooks fill the functional space between the Python shell and an editor. In a notebook, the results of expressions are printed below once evaluated, but the code remains in an editable state after execution. Notebooks also provide the ability to document / annotate your code using special Markdown cells. If a graphics enabled Python library is used in a Jupyter notebook, the graphics are displayed inline in the Notebook. All of these features make notebooks the most visual way to develop Python. Visit the RealPython article on getting started with Jupyter Notebooks. Thoughts on Notebooks: Notebooks are a great way to learn and develop Python Notebooks are widely used in the data science and academic domains Notebooks are very visual--graphics and results are displayed alongside the code that produced them. Caution : Notebooks can lead to strange issues related to execution order. Example: it is possible to run a cell that depends on another cell before the prerequisite cell is executed. This can lead to confusing or erroneous results and care must be taken to avoid this issue. Side benefit : The IPython shell is installed when you install Jupyter Lab or classic Jupyter Notebooks. This advanced Python shell has many wonderful features. Related Resources \u00b6 From the official Documentation Using the Python Interpreter Discusses launching the Python interpreter from the commandline.","title":"Setting up Python"},{"location":"02/02-setting-up-python/#downloading-python","text":"The Python version supported by this text is version 3.10.x (note that the x can be any number). When downloading Python, please be sure to select this version. Official Python releases are available from the official Python Page . The site auto detects your operating system and provides a link to the most current version. If the target version is not listed, you can visit the All Releases page to locate it.","title":"Downloading Python"},{"location":"02/02-setting-up-python/#installing-python","text":"For installation instructions, I will lean on the expertise of the RealPython team. This platform maintains up-to-date, community reviewed instuctions and articles on many Python related topics. Visit the RealPython installation instructions for an up-to-date guide on installing for your operating system and platform. For Windows Users... Do not install the Microsoft Store version of Python. Be sure to install the package available from the official Python page.","title":"Installing Python"},{"location":"02/02-setting-up-python/#using-the-idle-ide","text":"An IDE (intgrated development environment) typically includes: an editor for editing code a method for building / running code a debugger for tracing program execution and troubleshooting errors Python programs are simply text files, so you can technically use your preferred plain text editor to edit Python code. However, you will need to rely on the operating system shell / terminal to run your code using the Python interpreter. An IDE simplifies your workflow when editing and running programs. For first time Python users, IDLE is a great choice for many reasons: IDLE is installed when you install Python using the official installer. IDLE is preconfigured and ready to use for Python development. IDLE is simpler than most IDEs. This text will refer only to IDLE when showing examples that involve an IDE.","title":"Using the IDLE IDE"},{"location":"02/02-setting-up-python/#launching-idle","text":"Launch IDLE using your favorite launch method. On most operating systems, the search feature is typically the fastest. On Windows, press the Windows key and start typing IDLE On macOS, type Command + SPACE and start typing IDLE When IDLE launches, you will be greeted by a window containing the Python shell. We'll refer to this as the \"shell window\" or \"interactive window\". The interactive window lets you interact with the Python interpreter directly by entering code statements and viewing the result. Python Shell / IDLE Interactive Window","title":"Launching IDLE"},{"location":"02/02-setting-up-python/#introducing-the-python-shell","text":"The default Python shell provides a simple Read-Evaluate-Print-Loop ( REPL ) interface to the Python interpreter. You are greeted with the Python shell when you start IDLE or launch the shell directly from an OS shell. Take a moment to explore the basic parts of the Python shell using the annotations below. Python 3.10.0 ( v3 .10.0 : b494f5935c , Oct 4 2021 , 14 : 59 : 19 ) [ Clang 12.0.5 ( clang - 1205.0.22.11 )] on darwin # (1)! Type \"help\" , \"copyright\" , \"credits\" or \"license()\" for more information . # (2)! >>> # (3)! >>> print ( 'Hello World!' ) # (4)! Hello World # (5)! >>> The Python version (here, 3.10.0) is shown at the beginning of a Python shell session. Don't overlook help here. Python's help feature is, well, helpful. The >>> shown here is the Python shell prompt. Never enter these characters explicitly when pasting example code. Enter a single line of Python code like this one. When you press +Enter+, the Python interpreter reads and evaluates the code. It then prints the result. The Python interpreter prints the result. Note the absences of the >>> prompt on the result line. Note The term \"shell\" is more commonly used to refer to an operating system command line interface such as CMD.exe on Windows or Terminal.app on macOS. \"Python shell\" will be used whenever referring to Python.","title":"Introducing the Python Shell"},{"location":"02/02-setting-up-python/#use-python-as-a-calculator","text":"You can use the Python shell as a simple calculator. Python arithmetic expressions use the following operators. example operation result mathematical operation 2 + 5 7 addition 2 - 5 -3 subtraction 5 / 2 2.5 float division 5 * 2 10 multiplication 2 ** 5 32 exponentiation 5 // 2 2 integer division 5 % 2 1 modulus operator When you enter one of these expression at the Python shell prompt the result will be printed below the prompt.","title":"Use Python as a Calculator"},{"location":"02/02-setting-up-python/#add-some-variables","text":"Variables are names (symbols) that refer to a value. In order to use a variable, a value must be assigned to it using the assignment operator = . Experimemnt with this a bit using single character variable names. x = 5 # (1)! y = 2 # (2)! x + y # (3)! The symbol (name) x now refers to the value 5 . The symbol y now refers to the value `2. In evaluating this expression, the Python interpreter retrieves the values referred to by the names ( x and y ) before evaluating the arithmetic expression.","title":"Add Some Variables"},{"location":"02/02-setting-up-python/#rules-for-names-in-python","text":"The rules for names in Python are simple, yet important. One common pitfall is forgetting that names are case sensitive in Python. This means that height and Height are different names in Python. A variable name must start with a letter or the underscore character ( _ ) A variable name cannot start with a number A variable name can only contain alpha-numeric characters and underscores ( A-Z , a-z , 0-9 , and _ ). Variable names are case-sensitive ( age , Age and AGE are three different variables)","title":"Rules for Names in Python"},{"location":"02/02-setting-up-python/#keyboard-shortcuts-in-the-shell","text":"shortcut operation Ctrl + P previous history Ctrl + N next history Ctrl + A beginning of line Ctrl + E end of line It is also worth noting that the previous result is always stored in the varaible _ . You can access this instead of copying and pasting a result. Example shell session: >>> x = 5 >>> y = 2 >>> x + y 7 >>> _ + 10 # (1)! 17 _ is a special Python shell variable that stores the result of the last expression evaluated by the interpreter. Use this instead of copying and pasting.","title":"Keyboard Shortcuts in the Shell"},{"location":"02/02-setting-up-python/#the-editor-window","text":"The Python shell is an essential development tool for quickly prototyping ideas. In a typical software development workflow, use of the Python shell is typically short-lived because we need our code to reside in a place where it can be re-used--in a file. We use the IDLE editor window for this. Files that contain Python code are referred to as Python scripts , modules , or simply Python files. script : a file containing Python code that is meant to be run directly--like a standalone program/application. module : A module is a file containing Python code that can be imported by other Python scripts or modules. ( Note that Python modules can also be run directly. )","title":"The Editor Window"},{"location":"02/02-setting-up-python/#edit-and-run-a-new-python-module","text":"When IDLE launches, only the Python shell window is displayed for use. You can open an editor window by selecting File -> New File . Try this now and enter the following calculator code into the resulting window. x = 5 y = 2 x + y You'll need to save this file with a Python extension .py before you can run it. Choose File -> Save (or Ctrl + S on , Cmd + S on ) Choose a file location and save the file as calculate.py . Now that you have saved the file, you can run the file using Run -> Run Module . Note that there is a keyboard shortcut for this as well --( F5 ) If you entered the exact code above in the file, you'll notice that there is no output when you run the module. This is one key difference between the editor and the Python shell. The Python shell always displays the result of an expression . When we run a module, the result of every expression is not printed to the screen. In order to view the results of expressions, we must use the print() function. Modify your code to include the modifications shown below: x = 5 y = 2 print ( x + y ) # (1)! Use print to display the result of (or value of) an expression.","title":"Edit and Run a New Python Module"},{"location":"02/02-setting-up-python/#edit-and-run-an-existing-python-module","text":"In IDLE , use FILE -> Open From the file browser, right-click the file and choose Open with IDLE Danger Double-clicking a Python file in the file browser will cause the module to be executed in the background.","title":"Edit and Run an Existing Python Module"},{"location":"02/02-setting-up-python/#learn-python-with-idle","text":"As you progress through the course, you will encounter many new language features. You can accelerate your learning by interacting with these features as soon as you encounter them. Use the Python shell to quickly try out Python code snippets found in this text. When code snippets begin to evolve into something you want to experiment with a bit more, use the editor to maintain the code in an editable file which you can run again and again. Here are some tips for learning with IDLE : Keep IDLE open while working through this text. Click the copy to clipboard icon next to any code in this text to copy the code. Paste the code into the Python shell to quickly view a result. Re-paste the code and make some modifications. Collect code snippets in a Python module for further modifications recall that you need to add print() to print any results that are not already printed.","title":"Learn Python with IDLE"},{"location":"02/02-setting-up-python/#other-ides","text":"It is highly recommended that you use IDLE initially if you are a just getting started with the Python language. IDLE is installed when you install Python from the offical Python site . Moreover, IDLE requires no additional configuration and its minimal interface keeps the focus on the language. As you become more comfortable with the language, you'll inevitably long for a more feature rich environment for developing Python code.","title":"Other IDEs"},{"location":"02/02-setting-up-python/#microsoft-visual-studio-code","text":"Visual Studio Code is a widely used IDE. VS Code is has strong support for Python via extensions. Visit the Real Python article on setting up VS Code for Python development. Thoughts on VS Code: VS Code requires a bit of configuration before it is in a usable state for Python development. VS Code is freely available and runs on most platforms.","title":"Microsoft Visual Studio Code"},{"location":"02/02-setting-up-python/#pycharm","text":"Pycharm is a JetBrains product. The education version is free, but you will need to verify student status--the process is simple and worth it. Visit the RealPython article on using PyCharm for development. Note PyCharm is a highly recommended IDE. Give it a try once you have some minimal experience programming Python with IDLE . PyCharm educational licenses are quite easy to obtain. Be sure to get the educational version (not the community edition). PyCharm integrates well with all Python environments and GitHub. It also supports notebooks. All of this comes with very minimal configuration compared to Jupyter and VS Code. Thoughts on PyCharm: PyCharm requires much less configuration compared to VS Code PyCharm is designed as a Python first IDE, so it is ready for Python development. PyCharm feels like more of a professional product compared to VS Code. This is, of course, subjective. PyCharm runs on Windows or macOS.","title":"Pycharm"},{"location":"02/02-setting-up-python/#jupyter-notebooks","text":"Jupyter Notebooks are a great way to develop Python. Jupyter Notebooks provide a browser based editing environment for Python. In a notebook, code is entered into \"cells\". Cells can be evaluated any number of times and the result is printed below the cell. Notebooks fill the functional space between the Python shell and an editor. In a notebook, the results of expressions are printed below once evaluated, but the code remains in an editable state after execution. Notebooks also provide the ability to document / annotate your code using special Markdown cells. If a graphics enabled Python library is used in a Jupyter notebook, the graphics are displayed inline in the Notebook. All of these features make notebooks the most visual way to develop Python. Visit the RealPython article on getting started with Jupyter Notebooks. Thoughts on Notebooks: Notebooks are a great way to learn and develop Python Notebooks are widely used in the data science and academic domains Notebooks are very visual--graphics and results are displayed alongside the code that produced them. Caution : Notebooks can lead to strange issues related to execution order. Example: it is possible to run a cell that depends on another cell before the prerequisite cell is executed. This can lead to confusing or erroneous results and care must be taken to avoid this issue. Side benefit : The IPython shell is installed when you install Jupyter Lab or classic Jupyter Notebooks. This advanced Python shell has many wonderful features.","title":"Jupyter Notebooks"},{"location":"02/02-setting-up-python/#related-resources","text":"From the official Documentation Using the Python Interpreter Discusses launching the Python interpreter from the commandline.","title":"Related Resources"},{"location":"03/03-long-strings/","text":"Handling Long Strings \u00b6 The PEP8 style guide requires that lines are no longer that 79 characters in width. This poses a challenge when we need to include long lines of text in our program. This section covers multiple approaches to dealing with long lines. Breaking Long Lines with Parentheses \u00b6 Python ignores any whitespace between parentheses. We can use this to our advantage when breaking long lines. Note in the following example that Python concatenates (puts together) the two string literals contained between the parens. >>> message = ( \"Hello \" \"there!\" ) >>> print ( message ) Hello there ! We now see that Python concatenates multiple strings when they are contained within parentheses. Let's use this feature to break up a long line. Copy and paste this into an editor window and run it to see this in action. string_examples.py very_long_line_of_text = ( \"Do all the good you can, by all the means you can, in all the ways you can,\" \"in all the places you can, at all the times you can, to all the people you can,\" \"as long as ever you can.\" ) print ( very_long_line_of_text ) And when we run string_examples.py , we see: >>> Do all the good you can, by all the means you can, in all the ways you can,in all the places you can, at all the times you can, to all the people you can,as long as ever you can. >>> Breaking long lines with parens is the cleanest approach to solving this problem in my opinion. There is another commonly used approach. Escaping Newlines with \\ \u00b6 The line continuation character \\ (backslash) instructs Python to ignore the newline character that follows. This can be used to break up long strings or other long lines. The modifications to string_examples.py below demonstrate this. Run the code yourself to see it in action and experiment with changes. The code does indeed print the same result as the last version. string_examples.py very_long_line_of_text = \"Do all the good you can, by all the means you can,\" \\ \" in all the ways you can, in all the places you can, at all the times you\" \\ \" can, to all the people you can, as long as ever you can.\" print ( very_long_line_of_text ) String Literals within Triple Quotes \u00b6 In the previous section, we saw how to ignore newlines in string literals. What if we want to preserve newlines and other spacing in our string literals? Enclosing a string literal in triple single or triple double quotes accomplishes this. Consider the text of a poem for example. Poems tend to have very specific formatting needs. The following classic poem by Langston Hughes is an example as Mr. Hughes used indentation and spacing in his style. Harlem, By Langston Hughes What happens to a dream deferred? Does it dry up like a raisin in the sun? Or fester like a sore\u2014 And then run? Does it stink like rotten meat? Or crust and sugar over\u2014 like a syrupy sweet? Maybe it just sags like a heavy load. Or does it explode? Surrounding such a block of text with triple double or triple single quotes will preserve all whitespace (tabs, spaces, newlines). Try adding the following code block to string_examples.py and running it to see this technique in action. string_examples.py harlem = \\ \"\"\"What happens to a dream deferred? Does it dry up like a raisin in the sun? Or fester like a sore\u2014 And then run? Does it stink like rotten meat? Or crust and sugar over\u2014 like a syrupy sweet? Maybe it just sags like a heavy load. Or does it explode? \"\"\" print ( harlem ) Triple-quoted Strings: Potential issues \u00b6 The whitespace preservation of triple-quoted strings is both a benefit and a problem--depending on the situation. Consider the situation illustrated below. The harlem variable from the previous section is now included in a function--note the additional indentation. The triple-quote's whitespace preservation keeps the additional indentation spaces in addition to the space in the original text. Note the result when you run this code. string_examples.py def print_poem (): harlem = \\ \"\"\"What happens to a dream deferred? Does it dry up like a raisin in the sun? Or fester like a sore\u2014 And then run? Does it stink like rotten meat? Or crust and sugar over\u2014 like a syrupy sweet? Maybe it just sags like a heavy load. Or does it explode? \"\"\" print ( harlem ) if __name__ == '__main__' : print_poem () Here's the output. Do you notice the additional spaces? Keep this in mind as a potential hazard to look out for. What happens to a dream deferred? Does it dry up like a raisin in the sun? Or fester like a sore\u2014 And then run? Does it stink like rotten meat? Or crust and sugar over\u2014 like a syrupy sweet? Maybe it just sags like a heavy load. Or does it explode?","title":"Long String Literals"},{"location":"03/03-long-strings/#handling-long-strings","text":"The PEP8 style guide requires that lines are no longer that 79 characters in width. This poses a challenge when we need to include long lines of text in our program. This section covers multiple approaches to dealing with long lines.","title":"Handling Long Strings"},{"location":"03/03-long-strings/#breaking-long-lines-with-parentheses","text":"Python ignores any whitespace between parentheses. We can use this to our advantage when breaking long lines. Note in the following example that Python concatenates (puts together) the two string literals contained between the parens. >>> message = ( \"Hello \" \"there!\" ) >>> print ( message ) Hello there ! We now see that Python concatenates multiple strings when they are contained within parentheses. Let's use this feature to break up a long line. Copy and paste this into an editor window and run it to see this in action. string_examples.py very_long_line_of_text = ( \"Do all the good you can, by all the means you can, in all the ways you can,\" \"in all the places you can, at all the times you can, to all the people you can,\" \"as long as ever you can.\" ) print ( very_long_line_of_text ) And when we run string_examples.py , we see: >>> Do all the good you can, by all the means you can, in all the ways you can,in all the places you can, at all the times you can, to all the people you can,as long as ever you can. >>> Breaking long lines with parens is the cleanest approach to solving this problem in my opinion. There is another commonly used approach.","title":"Breaking Long Lines with Parentheses"},{"location":"03/03-long-strings/#escaping-newlines-with","text":"The line continuation character \\ (backslash) instructs Python to ignore the newline character that follows. This can be used to break up long strings or other long lines. The modifications to string_examples.py below demonstrate this. Run the code yourself to see it in action and experiment with changes. The code does indeed print the same result as the last version. string_examples.py very_long_line_of_text = \"Do all the good you can, by all the means you can,\" \\ \" in all the ways you can, in all the places you can, at all the times you\" \\ \" can, to all the people you can, as long as ever you can.\" print ( very_long_line_of_text )","title":"Escaping Newlines with \\"},{"location":"03/03-long-strings/#string-literals-within-triple-quotes","text":"In the previous section, we saw how to ignore newlines in string literals. What if we want to preserve newlines and other spacing in our string literals? Enclosing a string literal in triple single or triple double quotes accomplishes this. Consider the text of a poem for example. Poems tend to have very specific formatting needs. The following classic poem by Langston Hughes is an example as Mr. Hughes used indentation and spacing in his style. Harlem, By Langston Hughes What happens to a dream deferred? Does it dry up like a raisin in the sun? Or fester like a sore\u2014 And then run? Does it stink like rotten meat? Or crust and sugar over\u2014 like a syrupy sweet? Maybe it just sags like a heavy load. Or does it explode? Surrounding such a block of text with triple double or triple single quotes will preserve all whitespace (tabs, spaces, newlines). Try adding the following code block to string_examples.py and running it to see this technique in action. string_examples.py harlem = \\ \"\"\"What happens to a dream deferred? Does it dry up like a raisin in the sun? Or fester like a sore\u2014 And then run? Does it stink like rotten meat? Or crust and sugar over\u2014 like a syrupy sweet? Maybe it just sags like a heavy load. Or does it explode? \"\"\" print ( harlem )","title":"String Literals within Triple Quotes"},{"location":"03/03-long-strings/#triple-quoted-strings-potential-issues","text":"The whitespace preservation of triple-quoted strings is both a benefit and a problem--depending on the situation. Consider the situation illustrated below. The harlem variable from the previous section is now included in a function--note the additional indentation. The triple-quote's whitespace preservation keeps the additional indentation spaces in addition to the space in the original text. Note the result when you run this code. string_examples.py def print_poem (): harlem = \\ \"\"\"What happens to a dream deferred? Does it dry up like a raisin in the sun? Or fester like a sore\u2014 And then run? Does it stink like rotten meat? Or crust and sugar over\u2014 like a syrupy sweet? Maybe it just sags like a heavy load. Or does it explode? \"\"\" print ( harlem ) if __name__ == '__main__' : print_poem () Here's the output. Do you notice the additional spaces? Keep this in mind as a potential hazard to look out for. What happens to a dream deferred? Does it dry up like a raisin in the sun? Or fester like a sore\u2014 And then run? Does it stink like rotten meat? Or crust and sugar over\u2014 like a syrupy sweet? Maybe it just sags like a heavy load. Or does it explode?","title":"Triple-quoted Strings: Potential issues"},{"location":"03/03-strings/","text":"Strings Review \u00b6 The str type was first introduced in Text Type . Here are some high-level str facts that were covered in that section: Use double ( \" ) or single ( ' ) quotes to delimit string literals. Calling type() on a str type will return the string 'str' . You can verify if a variable is a str type with isinstance() . Strings can be concatenated using the + operator. String Indexing \u00b6 Python str types are sequence types composed of 1 or more str types. This is a strange way to describe them, but it is true. We can the items in a string using square bracket indexing where the index values start at 0 and end at length - 1 where length is the length of the string. letters = 'ABCD' # (1)! A = letters [ 0 ] # (2)! B = letters [ 1 ] C = letters [ 2 ] D = letters [ 3 ] # (3)! letters is a str of length 3. The first index is 0 The final index (the index of the last text character) is length - 1 or 3 in this case. Slicing \u00b6 Slicing is an operation that all sequence types have in common. Slices provide a way to index multiple parts of a sequence. For strings, slices are sub strings of the parent string. To slice a string, index with the pattern [start:stop:step] (similar to range() arguments). Note that stop is not included in the output. Indices from start to stop - 1 are returned. The step controls the numerical distance between each of the indices in the slice. The following examples demonstrate. slice_example_1.py full_name = 'Albert Einstein' first_name = full_name [: 6 ] # start defaults to 0 last_name = full_name [ 7 :] # end defaults to the last index + 1 print ( f 'first_name = { first_name } ' ) print ( f 'last_name = { last_name } ' ) slice_example_2.py numbers = '0123456789' multiples_of_two = numbers [:: 2 ] # step is two multiples_of_three = numbers [:: 3 ] # step is three print ( f 'multiples_of_two = { multiples_of_two } ' ) print ( f 'multiples_of_three = { multiples_of_three } ' ) Named Slices \u00b6 Named slices are useful when a slice needs to be reused. The slice() function can be used to assign a slice object to a name which can then be used to slice other sequences. Pass at least one of start , stop , step to slice() and fill any missing arguments with None . We can re-code slice_example_2.py with named slices: numbers = '0123456789' twos_slice = slice ( 0 , None , 2 ) threes_slice = slice ( 0 , None , 3 ) multiples_of_two = numbers [ twos_slice ] # step is two multiples_of_three = numbers [ threes_slice ] # step is three print ( f 'multiples_of_two = { multiples_of_two } ' ) print ( f 'multiples_of_three = { multiples_of_three } ' ) Parsing fixed-width field ( FWF ) files is a common use case for named slices. FWF files store data in columns of a fixed length of characters and are a common format for importing to and from databases. The following is an example of a FWF data file: countries.txt IN India New Delhi NL Netherlands Amsterdam US United States Washington D.C. In countries.txt , the columns occupy the following ranges of characters: column ranges COUNTRY_CODE: [0, 1,] COUNTRY_NAME: [3, 4, ..., 22] COUNTRY_CAPITAL: [24, 25, ..., 43] We can name slices for the fields for reuse and increased readability: slice_countries.py CODE = slice ( 0 , 2 ) NAME = slice ( 3 , 23 ) CAPITAL = slice ( 24 , 44 ) # (1)! countries_fwf = \"\"\"IN India New Delhi NL Netherlands Amsterdam US United States Washington D.C. \"\"\" # Consume each field and print only the capital for line in countries_fwf . splitlines (): # (2)! code , name , capital = line [ CODE ], line [ NAME ], line [ CAPITAL ] print ( capital . strip ()) # (3)! countries_fwf is a triple-quoted string which preserves formatting. This is a fixed-width field formatted string using the field widths defined above. The splitlines() method is a string method that splits a string object on line breaks and returns a list where each item is a line. The strip() method is a string method that removes any spaces, newlines, tabs (whitespace) from the beginning or the end of a string. Without the use of the strip() method, the additional spaces in the name and capital fields would still be present. Many other useful string methods are covered later on this page. Converting Numbers to Strings \u00b6 f-Strings \u00b6 f-strings, added in Python 3.6, simplified string formatting strings preceded by f are considered f-strings Any Python expression enclosed in {} is replaced with its value in the returned string. lang = \"Python\" ver = 2.4 formatted = f \"My first { lang } version was ver { version } \" print ( formatted ) f-strings (new in 3.8) \u00b6 Python 3.8 introduced the debugging specifier = prints the expression, followed by = , followed by the value of the expression useful for debugging and logging. print ( f \" { lang =} \\n { ver =} \" ) a , b = 2000 , 22 print ( f \" \\n { a + b = } \" ) Format Specificiers \u00b6 control how numbers (and other types) are printed included at the end of the {} placeholder This example demonstrates a basic use case. Note that USD currency rarely includes fractional cents. subtotal = 1.49 tax = 0.33 total = subtotal * ( 1 + tax ) msg = f \"The total is $ { total } \" print ( msg ) Specify Precision \u00b6 Use {:.[precision]f} with floating point types to limit the number of decimal places to precision places. msg = f \"The total is $ { total : 0.2f } \" print ( msg ) Other Format Control Options \u00b6 The full format control string allows for the following fields: Type \u00b6 The type specifier type provides representation conversion for numbers. [fill][align][sign][width].[precision][type] type_specifiers.py 1 2 3 4 5 6 7 8 9 10 11 12 num = 224 print ( f 'with d: { num : d } ' ) # this is the default for integers print ( f 'with f: { num : f } ' ) # floating point display print ( f 'with x: { num : x } ' ) # lowcase hexadecimal representation print ( f 'with X: { num : X } ' ) # UPCASE hexadecimal representation print ( f 'with b: { num : b } ' ) # binary representation print ( f 'with o: { num : o } ' ) # octal representation print ( f 'with f: { num : f } ' ) # default for floating point types print ( f 'with e: { num : e } ' ) # lowcase exponential (scientific) notation print ( f 'with E: { num : E } ' ) # UPCASE exponential notation print ( f 'with %: { num : % } ' ) # With %, the value is first multiplied by 100 Output for type_specifiers.py (Line numbers match the associated source line) 2 3 4 5 6 7 8 9 10 11 with d: 224 with f: 224.000000 with x: e0 with X: E0 with b: 11100000 with o: 340 with f: 224.000000 with e: 2.240000e+02 with E: 2.240000E+02 with %: 22400.000000% Field Width \u00b6 Control the width of the field (as in FWF formatting) with the width field in the format string. [fill][align][sign][width].[precision][type] field_width.py 1 2 3 4 5 6 7 subtotal = 1.49 tax = 0.33 total = subtotal * ( 1 + tax ) print ( f \"total: { total : 0.2f } \" ) print ( f \"total: { total : 10.2f } \" ) print ( f \"total: { total : 20.2f } \" ) Output of field_width.py (Line numbers match the associated source line). 5 6 7 total: 1.98 total: 1.98 total: 1.98 Sign \u00b6 sign : the sign option is only valid for number types. + : indicates that a sign should be used for both positive as well as negative numbers. - : indicates that a sign should be used only for negative numbers (this is the default behavior). : (space) indicates that a leading space should be used on positive numbers, and a minus sign on negative [fill][align][sign][width].[precision][type] sign.py 1 2 3 4 5 6 7 8 subtotal = 1.49 tax = 0.33 total = subtotal * ( 1 + tax ) print ( f \"total: { total : +.2f } \" ) print ( f \"total: { - total : -.2f } \" ) print ( f \"total: { total : .2f } \" ) print ( f \"total: { - total : .2f } \" ) Output of sign.py (Line numbers match the associated source line). linenums=\"5\" total: +1.98 total: -1.98 total: 1.98 total: -1.98 String Methods \u00b6 Methods are functions (like print() ) that are \" attached \" to objects. String methods are functions attached to str objects. Use the .method() pattern for calling Some useful methods: .upper() : returns an UPPERCASE copy of the string .lower() : returns a lowercase copy of the string .title() : returns a Title Case copy fo the string .strip() , .rstrip() , and .lstrip() .startswith() , .endswith() .split() and .splitlines() are string methods that return list types. String Methods (new since 3.9) \u00b6 .removeprefix(prefix) : removes the prefix substring prefix if present. .removesuffix(suffix) : removes a suffix if present.","title":"Strings and String Methods"},{"location":"03/03-strings/#strings-review","text":"The str type was first introduced in Text Type . Here are some high-level str facts that were covered in that section: Use double ( \" ) or single ( ' ) quotes to delimit string literals. Calling type() on a str type will return the string 'str' . You can verify if a variable is a str type with isinstance() . Strings can be concatenated using the + operator.","title":"Strings Review"},{"location":"03/03-strings/#string-indexing","text":"Python str types are sequence types composed of 1 or more str types. This is a strange way to describe them, but it is true. We can the items in a string using square bracket indexing where the index values start at 0 and end at length - 1 where length is the length of the string. letters = 'ABCD' # (1)! A = letters [ 0 ] # (2)! B = letters [ 1 ] C = letters [ 2 ] D = letters [ 3 ] # (3)! letters is a str of length 3. The first index is 0 The final index (the index of the last text character) is length - 1 or 3 in this case.","title":"String Indexing"},{"location":"03/03-strings/#slicing","text":"Slicing is an operation that all sequence types have in common. Slices provide a way to index multiple parts of a sequence. For strings, slices are sub strings of the parent string. To slice a string, index with the pattern [start:stop:step] (similar to range() arguments). Note that stop is not included in the output. Indices from start to stop - 1 are returned. The step controls the numerical distance between each of the indices in the slice. The following examples demonstrate. slice_example_1.py full_name = 'Albert Einstein' first_name = full_name [: 6 ] # start defaults to 0 last_name = full_name [ 7 :] # end defaults to the last index + 1 print ( f 'first_name = { first_name } ' ) print ( f 'last_name = { last_name } ' ) slice_example_2.py numbers = '0123456789' multiples_of_two = numbers [:: 2 ] # step is two multiples_of_three = numbers [:: 3 ] # step is three print ( f 'multiples_of_two = { multiples_of_two } ' ) print ( f 'multiples_of_three = { multiples_of_three } ' )","title":"Slicing"},{"location":"03/03-strings/#named-slices","text":"Named slices are useful when a slice needs to be reused. The slice() function can be used to assign a slice object to a name which can then be used to slice other sequences. Pass at least one of start , stop , step to slice() and fill any missing arguments with None . We can re-code slice_example_2.py with named slices: numbers = '0123456789' twos_slice = slice ( 0 , None , 2 ) threes_slice = slice ( 0 , None , 3 ) multiples_of_two = numbers [ twos_slice ] # step is two multiples_of_three = numbers [ threes_slice ] # step is three print ( f 'multiples_of_two = { multiples_of_two } ' ) print ( f 'multiples_of_three = { multiples_of_three } ' ) Parsing fixed-width field ( FWF ) files is a common use case for named slices. FWF files store data in columns of a fixed length of characters and are a common format for importing to and from databases. The following is an example of a FWF data file: countries.txt IN India New Delhi NL Netherlands Amsterdam US United States Washington D.C. In countries.txt , the columns occupy the following ranges of characters: column ranges COUNTRY_CODE: [0, 1,] COUNTRY_NAME: [3, 4, ..., 22] COUNTRY_CAPITAL: [24, 25, ..., 43] We can name slices for the fields for reuse and increased readability: slice_countries.py CODE = slice ( 0 , 2 ) NAME = slice ( 3 , 23 ) CAPITAL = slice ( 24 , 44 ) # (1)! countries_fwf = \"\"\"IN India New Delhi NL Netherlands Amsterdam US United States Washington D.C. \"\"\" # Consume each field and print only the capital for line in countries_fwf . splitlines (): # (2)! code , name , capital = line [ CODE ], line [ NAME ], line [ CAPITAL ] print ( capital . strip ()) # (3)! countries_fwf is a triple-quoted string which preserves formatting. This is a fixed-width field formatted string using the field widths defined above. The splitlines() method is a string method that splits a string object on line breaks and returns a list where each item is a line. The strip() method is a string method that removes any spaces, newlines, tabs (whitespace) from the beginning or the end of a string. Without the use of the strip() method, the additional spaces in the name and capital fields would still be present. Many other useful string methods are covered later on this page.","title":"Named Slices"},{"location":"03/03-strings/#converting-numbers-to-strings","text":"","title":"Converting Numbers to Strings"},{"location":"03/03-strings/#f-strings","text":"f-strings, added in Python 3.6, simplified string formatting strings preceded by f are considered f-strings Any Python expression enclosed in {} is replaced with its value in the returned string. lang = \"Python\" ver = 2.4 formatted = f \"My first { lang } version was ver { version } \" print ( formatted )","title":"f-Strings"},{"location":"03/03-strings/#f-strings-new-in-38","text":"Python 3.8 introduced the debugging specifier = prints the expression, followed by = , followed by the value of the expression useful for debugging and logging. print ( f \" { lang =} \\n { ver =} \" ) a , b = 2000 , 22 print ( f \" \\n { a + b = } \" )","title":"f-strings (new in 3.8)"},{"location":"03/03-strings/#format-specificiers","text":"control how numbers (and other types) are printed included at the end of the {} placeholder This example demonstrates a basic use case. Note that USD currency rarely includes fractional cents. subtotal = 1.49 tax = 0.33 total = subtotal * ( 1 + tax ) msg = f \"The total is $ { total } \" print ( msg )","title":"Format Specificiers"},{"location":"03/03-strings/#specify-precision","text":"Use {:.[precision]f} with floating point types to limit the number of decimal places to precision places. msg = f \"The total is $ { total : 0.2f } \" print ( msg )","title":"Specify Precision"},{"location":"03/03-strings/#other-format-control-options","text":"The full format control string allows for the following fields:","title":"Other Format Control Options"},{"location":"03/03-strings/#type","text":"The type specifier type provides representation conversion for numbers. [fill][align][sign][width].[precision][type] type_specifiers.py 1 2 3 4 5 6 7 8 9 10 11 12 num = 224 print ( f 'with d: { num : d } ' ) # this is the default for integers print ( f 'with f: { num : f } ' ) # floating point display print ( f 'with x: { num : x } ' ) # lowcase hexadecimal representation print ( f 'with X: { num : X } ' ) # UPCASE hexadecimal representation print ( f 'with b: { num : b } ' ) # binary representation print ( f 'with o: { num : o } ' ) # octal representation print ( f 'with f: { num : f } ' ) # default for floating point types print ( f 'with e: { num : e } ' ) # lowcase exponential (scientific) notation print ( f 'with E: { num : E } ' ) # UPCASE exponential notation print ( f 'with %: { num : % } ' ) # With %, the value is first multiplied by 100 Output for type_specifiers.py (Line numbers match the associated source line) 2 3 4 5 6 7 8 9 10 11 with d: 224 with f: 224.000000 with x: e0 with X: E0 with b: 11100000 with o: 340 with f: 224.000000 with e: 2.240000e+02 with E: 2.240000E+02 with %: 22400.000000%","title":"Type"},{"location":"03/03-strings/#field-width","text":"Control the width of the field (as in FWF formatting) with the width field in the format string. [fill][align][sign][width].[precision][type] field_width.py 1 2 3 4 5 6 7 subtotal = 1.49 tax = 0.33 total = subtotal * ( 1 + tax ) print ( f \"total: { total : 0.2f } \" ) print ( f \"total: { total : 10.2f } \" ) print ( f \"total: { total : 20.2f } \" ) Output of field_width.py (Line numbers match the associated source line). 5 6 7 total: 1.98 total: 1.98 total: 1.98","title":"Field Width"},{"location":"03/03-strings/#sign","text":"sign : the sign option is only valid for number types. + : indicates that a sign should be used for both positive as well as negative numbers. - : indicates that a sign should be used only for negative numbers (this is the default behavior). : (space) indicates that a leading space should be used on positive numbers, and a minus sign on negative [fill][align][sign][width].[precision][type] sign.py 1 2 3 4 5 6 7 8 subtotal = 1.49 tax = 0.33 total = subtotal * ( 1 + tax ) print ( f \"total: { total : +.2f } \" ) print ( f \"total: { - total : -.2f } \" ) print ( f \"total: { total : .2f } \" ) print ( f \"total: { - total : .2f } \" ) Output of sign.py (Line numbers match the associated source line). linenums=\"5\" total: +1.98 total: -1.98 total: 1.98 total: -1.98","title":"Sign"},{"location":"03/03-strings/#string-methods","text":"Methods are functions (like print() ) that are \" attached \" to objects. String methods are functions attached to str objects. Use the .method() pattern for calling Some useful methods: .upper() : returns an UPPERCASE copy of the string .lower() : returns a lowercase copy of the string .title() : returns a Title Case copy fo the string .strip() , .rstrip() , and .lstrip() .startswith() , .endswith() .split() and .splitlines() are string methods that return list types.","title":"String Methods"},{"location":"03/03-strings/#string-methods-new-since-39","text":".removeprefix(prefix) : removes the prefix substring prefix if present. .removesuffix(suffix) : removes a suffix if present.","title":"String Methods (new since 3.9)"},{"location":"04/04-lists/","text":"Python Lists \u00b6 The list type was first introduced in Text_Type . Lists are a mutable sequence type in Python. This means that lists have and order and can be modified in place (without having to create a copy). Lists are arguable the most widely used collection type in Python. Review of the Basics \u00b6 lists contain sequences of objects (any Python type) list elements can be of mixed types index elements of a list just like any other sequence type","title":"List Essentials"},{"location":"04/04-lists/#python-lists","text":"The list type was first introduced in Text_Type . Lists are a mutable sequence type in Python. This means that lists have and order and can be modified in place (without having to create a copy). Lists are arguable the most widely used collection type in Python.","title":"Python Lists"},{"location":"04/04-lists/#review-of-the-basics","text":"lists contain sequences of objects (any Python type) list elements can be of mixed types index elements of a list just like any other sequence type","title":"Review of the Basics"},{"location":"guides/github-references/","text":"Introduction \u00b6 This reference is for students taking the course associated with this text. Assignments in the course will be submitted via GitHub Classroom. This document links relevant supporting references from the Git and GitHub Learning Resources page. Create a GitHub Account \u00b6 Students will need a GitHub account in order to complete assignments in the course. Assignment instructions, starter code, and supporting data are all available via a GitHub repository which is available to students once they accept the assignment invitation. Moreover, industry standard CI tools are used to grade student work. In order to access assignments, a GitHub account is needed. Note that there is no requirement that you use your university email address when signing up. You may even use an existing GitHub account. If you do not already have a GitHub account, sign up for one at GitHub . Info Visit the GitHub guide to creating an account Installing GitHub Desktop \u00b6 Git is a version control system that tracks changes to text based files (like Python code) which are stored in a git repository (repo). A repository is a directory that a git application watches for changes. Git provides: snapshots of changes / change sets the ability to merge several sets of changes the ability to roll back changes branching changes where a set of changes to a codebase can be developed separately from the primary codebase. both local and remote repository change syncing via commits (adding changes to history), pushing (sending local changes to remote), and pulling (retrieving changes from the remote). GitHub provides access to all of this functionality via the GitHub Desktop App GitHub Desktop: Viewing file differences. Info Visit the GitHub guide to Getting Started with GitHub Desktop Accepting an Assignment \u00b6 In order to begin working on an assignment, students must accept an assignment invitation link. The steps involved in accepting a link are as follows: Click the invitation link. Your browser will open to a GitHub classroom assignment page. Select Yourself from the List Next, select your name from the student identifier list to link your GitHub account to the assignment. This list should contain an entry that you can use to uniquely identify yourself--Name, Username, and Email are present. *Note: If your name is not present, select \"skip to the next step\" and inform your instructor that you need to be added to the list. The next screen that greets you is the assignment acceptance screen . Click \"Accept this Assignment\". Accept the Assignment When you accept the assignment, a copy of the assignment repository is copied to your account so that you can work with it. The screen that appears notes that you need to refresh the page to get the link. When you refresh the page, you'll be greeted with a link. Repository Ready... click the link. Working on the Assignment \u00b6 Read the README.md \u00b6 In order to begin working on the assignment, you'll first want to review the README. md that you are greeted by when you first visit your repository. This will be present for every assignment and it provides detailed instructions and assignment requirements. Viewing the README Clone your Repository \u00b6 While it is possible to edit files using the GitHub web application, this is not a good idea for Python development. The web editor does not have access to a shell for testing and it does not come with a debugger. The standard approach is to clone your repository. Cloning takes care of three essential tasks: copying the repository assets: source code, data files, tests, etc. copying the git configuration (necessary for git to work with your repo) copying the repository history (necessary for tracking and updating) Cloning can be accomplished by several methods: using GitHub desktop (recommended) using the command line (terminal) which requires that you have Git for Windows or if you are on macOS, macOS XCode command-line utilities . using and IDE. PyCharm can directly open your GitHub repository for example. Recommendation Cloning your repo via GitHub Desktop is highly recommended when starting out. Check out the GitHub documentation on cloning . Browse the Repository with File Explorer \u00b6 Once you have cloned your repository, GitHub Desktop presents you with three options in the main application pane: Open the repository in an IDE (Like PyCharm or VSCode) Open the repository with a File Browser (Windows Explorer for example) Open the repository on GitHub. For editing files locally, choose the 2nd option. Edit Python Source Files \u00b6 A template Python file is present for every sub-part of any assignment. These files are located in the src directory of your repository. Use a file browser to navigate to the source directory. . \u251c\u2500\u2500 README.md \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 src <---- Assignment templates are here \u2514\u2500\u2500 tests Any text editor can be used to modify Python source code since Python modules are plain text files. It is better to use a Python-aware editor like the editor present in IDLE , PyCharm or VS Code. Danger When opening a Python module for editing, *always right-click and choose Open With. ..*. If you double-click a Python module, the operating system will run the file. Commit Local Changes, Push to Submit to GitHub \u00b6 When you make progress on your assignment, it is best to commit those changes. When you do this, you create a snapshot that can be restored if necessary. Once you have reached a milestone or completed your assignment it is time to push those changes to GitHub. Danger You are encouraged to work only on the main branch for assignments in this course. Assignment submissions must be committed to and pushed to the main branch. Reference the GitHub instructions on committing and pushing. GitHub Reference: committing GitHub Reference: pushing Viewing Auto-grading Results \u00b6 When you make significant progress on your assignment, you'll likely want to know how you are doing. Each time you push changes to GitHub, a CI pipeline runs checks on your code. These checks consist of: unit tests (written for pytest ) these assure that your solutions meet the requirements and are used for autograding. style checks (via pytest-flake8 ) style checks assure that your code style adheres to the subset of the PEP8 style guide adopted for the course. You can view the output of these tests via the GitHub classroom interface or within GitHub itself. If any checks fail, the log will help you determine the necessary fixes. Check out the documentation on viewing auto-grading output . Note The same checks that are run when you push to GitHub can be run locally. To accomplish this, pytest will need to be installed locally as well. The easiest way to assure that you have the appropriate tools in place to test is to install the requirements listed in the requirements.txt file located in you repo. This is the topic of another article. Related Links \u00b6 Configure Pycharm for GitHub Configure VS Code for GitHub","title":"GitHub"},{"location":"guides/github-references/#introduction","text":"This reference is for students taking the course associated with this text. Assignments in the course will be submitted via GitHub Classroom. This document links relevant supporting references from the Git and GitHub Learning Resources page.","title":"Introduction"},{"location":"guides/github-references/#create-a-github-account","text":"Students will need a GitHub account in order to complete assignments in the course. Assignment instructions, starter code, and supporting data are all available via a GitHub repository which is available to students once they accept the assignment invitation. Moreover, industry standard CI tools are used to grade student work. In order to access assignments, a GitHub account is needed. Note that there is no requirement that you use your university email address when signing up. You may even use an existing GitHub account. If you do not already have a GitHub account, sign up for one at GitHub . Info Visit the GitHub guide to creating an account","title":"Create a GitHub Account"},{"location":"guides/github-references/#installing-github-desktop","text":"Git is a version control system that tracks changes to text based files (like Python code) which are stored in a git repository (repo). A repository is a directory that a git application watches for changes. Git provides: snapshots of changes / change sets the ability to merge several sets of changes the ability to roll back changes branching changes where a set of changes to a codebase can be developed separately from the primary codebase. both local and remote repository change syncing via commits (adding changes to history), pushing (sending local changes to remote), and pulling (retrieving changes from the remote). GitHub provides access to all of this functionality via the GitHub Desktop App GitHub Desktop: Viewing file differences. Info Visit the GitHub guide to Getting Started with GitHub Desktop","title":"Installing GitHub Desktop"},{"location":"guides/github-references/#accepting-an-assignment","text":"In order to begin working on an assignment, students must accept an assignment invitation link. The steps involved in accepting a link are as follows: Click the invitation link. Your browser will open to a GitHub classroom assignment page. Select Yourself from the List Next, select your name from the student identifier list to link your GitHub account to the assignment. This list should contain an entry that you can use to uniquely identify yourself--Name, Username, and Email are present. *Note: If your name is not present, select \"skip to the next step\" and inform your instructor that you need to be added to the list. The next screen that greets you is the assignment acceptance screen . Click \"Accept this Assignment\". Accept the Assignment When you accept the assignment, a copy of the assignment repository is copied to your account so that you can work with it. The screen that appears notes that you need to refresh the page to get the link. When you refresh the page, you'll be greeted with a link. Repository Ready... click the link.","title":"Accepting an Assignment"},{"location":"guides/github-references/#working-on-the-assignment","text":"","title":"Working on the Assignment"},{"location":"guides/github-references/#read-the-readmemd","text":"In order to begin working on the assignment, you'll first want to review the README. md that you are greeted by when you first visit your repository. This will be present for every assignment and it provides detailed instructions and assignment requirements. Viewing the README","title":"Read the README.md"},{"location":"guides/github-references/#clone-your-repository","text":"While it is possible to edit files using the GitHub web application, this is not a good idea for Python development. The web editor does not have access to a shell for testing and it does not come with a debugger. The standard approach is to clone your repository. Cloning takes care of three essential tasks: copying the repository assets: source code, data files, tests, etc. copying the git configuration (necessary for git to work with your repo) copying the repository history (necessary for tracking and updating) Cloning can be accomplished by several methods: using GitHub desktop (recommended) using the command line (terminal) which requires that you have Git for Windows or if you are on macOS, macOS XCode command-line utilities . using and IDE. PyCharm can directly open your GitHub repository for example. Recommendation Cloning your repo via GitHub Desktop is highly recommended when starting out. Check out the GitHub documentation on cloning .","title":"Clone your Repository"},{"location":"guides/github-references/#browse-the-repository-with-file-explorer","text":"Once you have cloned your repository, GitHub Desktop presents you with three options in the main application pane: Open the repository in an IDE (Like PyCharm or VSCode) Open the repository with a File Browser (Windows Explorer for example) Open the repository on GitHub. For editing files locally, choose the 2nd option.","title":"Browse the Repository with File Explorer"},{"location":"guides/github-references/#edit-python-source-files","text":"A template Python file is present for every sub-part of any assignment. These files are located in the src directory of your repository. Use a file browser to navigate to the source directory. . \u251c\u2500\u2500 README.md \u251c\u2500\u2500 requirements.txt \u251c\u2500\u2500 src <---- Assignment templates are here \u2514\u2500\u2500 tests Any text editor can be used to modify Python source code since Python modules are plain text files. It is better to use a Python-aware editor like the editor present in IDLE , PyCharm or VS Code. Danger When opening a Python module for editing, *always right-click and choose Open With. ..*. If you double-click a Python module, the operating system will run the file.","title":"Edit Python Source Files"},{"location":"guides/github-references/#commit-local-changes-push-to-submit-to-github","text":"When you make progress on your assignment, it is best to commit those changes. When you do this, you create a snapshot that can be restored if necessary. Once you have reached a milestone or completed your assignment it is time to push those changes to GitHub. Danger You are encouraged to work only on the main branch for assignments in this course. Assignment submissions must be committed to and pushed to the main branch. Reference the GitHub instructions on committing and pushing. GitHub Reference: committing GitHub Reference: pushing","title":"Commit Local Changes, Push to Submit to GitHub"},{"location":"guides/github-references/#viewing-auto-grading-results","text":"When you make significant progress on your assignment, you'll likely want to know how you are doing. Each time you push changes to GitHub, a CI pipeline runs checks on your code. These checks consist of: unit tests (written for pytest ) these assure that your solutions meet the requirements and are used for autograding. style checks (via pytest-flake8 ) style checks assure that your code style adheres to the subset of the PEP8 style guide adopted for the course. You can view the output of these tests via the GitHub classroom interface or within GitHub itself. If any checks fail, the log will help you determine the necessary fixes. Check out the documentation on viewing auto-grading output . Note The same checks that are run when you push to GitHub can be run locally. To accomplish this, pytest will need to be installed locally as well. The easiest way to assure that you have the appropriate tools in place to test is to install the requirements listed in the requirements.txt file located in you repo. This is the topic of another article.","title":"Viewing Auto-grading Results"},{"location":"guides/github-references/#related-links","text":"Configure Pycharm for GitHub Configure VS Code for GitHub","title":"Related Links"},{"location":"guides/pytest-reference/","text":"Introduction \u00b6 Pytest is an open source, third-party test runner for Python. It is arguably the simplest test runner available for Python. There is a lot that could be written about pytest and this reference does not attempt full coverage of the topic. The purpose of this reference is to provide students with a quick reference to useful pytest tips and command examples. Installing Pytest \u00b6 Installation is \"automatic\" for those of you that are using PyCharm to work on your projects. PyCharm will prompt you to install the packages listed in the requirements. txt file within your assignment repository. Info Python projects often use a file named requirements.txt to list project dependencies. Dependencies are other Python packages must be installed in order for the target application to run properly. requirements.txt files include a list of package names along with a minimum (or specific) required version. The Python package installer pip provides a way to easily install these packages. If you would like to install pytest in your main Python installation, you can run the following at the command prompt: Windows Linux/macOS PS> python -m pip install pytest $ python3 -m pip install pytest Useful pytest Command Variations \u00b6 In the context of this course, any of these commands should work when run from the command line at the root of your repository . Note PyCharm provides the Terminal tab at the bottom of the main window. This will launch a terminal session at the root of your repository. If you are on Windows, this defaults to a Powershell (PS) term. On macOS, the default is a ZSH term; on Linux this is likely a BaSH terminal. Run all Tests \u00b6 If you want to run all tests on your code, run the following command: pytest Filter Tests \u00b6 A typical professional Python project will include hundreds (or more) tests. It is often desirable to filter these tests. Pytest makes this possible with the filter command option -k . Use the command pytest -k <filter_text> where <filter_text> is a string of text that pytest will use to match test cases. Test cases are typically the functions contained in modules under the tests directory. Consider the following project structure: . \u251c\u2500\u2500 demo_pytest \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 clean.py \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_clean.py The clean.py module has the following simple contents. Note that there are just two functions contained in this module. clean.py \"\"\" clean.py contains utility functions for cleaning text. \"\"\" def clean_spaces ( text ): \"\"\" Removes spaces from the input text. Parameters ---------- text the text to be cleaned. Returns ------- the text with all spaces removed. \"\"\" return text . replace ( ' ' , '' ) def clean_underscores ( text ): \"\"\" Removes underscores from the input text. Parameters ---------- text the text to be cleaned. Returns ------- the text with all underscores removed. \"\"\" return text . replace ( '_' , '' ) The tests/test_clean.py module contains functions that test functions in the clean module. Note that there are multiple test functions here for the clean_spaces() function and just one test function for the clean_underscores() function. Each of the functions in the test_clean.py module are test cases. test_clean.py from demo_pytest.clean import clean_spaces , clean_underscores def test___clean_spaces___removes_leading_space (): input_ , expected = \" Hello\" , \"Hello\" assert clean_spaces ( input_ ) == expected def test___clean_spaces___removes_trailing_spaces (): input_ , expected = \"Hello \" , \"Hello\" assert clean_spaces ( input_ ) == expected def test___clean_spaces___removes_bounded_spaces (): input_ , expected = \"Hello There\" , \"HelloThere\" assert clean_spaces ( input_ ) == expected def test___clean_underscores___removes_all_underscores (): input_ , expected = \"_Hello_There_You_\" , \"HelloThereYou\" assert clean_underscores ( input_ ) == expected Pytest will only run tests for clean_spaces() if we use clean_spaces as the filter text: pytest -k \"clean_spaces\" Similarly, the following command runs only those test cases that contain the text clean_underscores in the function name: pytest -k \"clean_underscores\"","title":"Pytest"},{"location":"guides/pytest-reference/#introduction","text":"Pytest is an open source, third-party test runner for Python. It is arguably the simplest test runner available for Python. There is a lot that could be written about pytest and this reference does not attempt full coverage of the topic. The purpose of this reference is to provide students with a quick reference to useful pytest tips and command examples.","title":"Introduction"},{"location":"guides/pytest-reference/#installing-pytest","text":"Installation is \"automatic\" for those of you that are using PyCharm to work on your projects. PyCharm will prompt you to install the packages listed in the requirements. txt file within your assignment repository. Info Python projects often use a file named requirements.txt to list project dependencies. Dependencies are other Python packages must be installed in order for the target application to run properly. requirements.txt files include a list of package names along with a minimum (or specific) required version. The Python package installer pip provides a way to easily install these packages. If you would like to install pytest in your main Python installation, you can run the following at the command prompt: Windows Linux/macOS PS> python -m pip install pytest $ python3 -m pip install pytest","title":"Installing Pytest"},{"location":"guides/pytest-reference/#useful-pytest-command-variations","text":"In the context of this course, any of these commands should work when run from the command line at the root of your repository . Note PyCharm provides the Terminal tab at the bottom of the main window. This will launch a terminal session at the root of your repository. If you are on Windows, this defaults to a Powershell (PS) term. On macOS, the default is a ZSH term; on Linux this is likely a BaSH terminal.","title":"Useful pytest Command Variations"},{"location":"guides/pytest-reference/#run-all-tests","text":"If you want to run all tests on your code, run the following command: pytest","title":"Run all Tests"},{"location":"guides/pytest-reference/#filter-tests","text":"A typical professional Python project will include hundreds (or more) tests. It is often desirable to filter these tests. Pytest makes this possible with the filter command option -k . Use the command pytest -k <filter_text> where <filter_text> is a string of text that pytest will use to match test cases. Test cases are typically the functions contained in modules under the tests directory. Consider the following project structure: . \u251c\u2500\u2500 demo_pytest \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 clean.py \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_clean.py The clean.py module has the following simple contents. Note that there are just two functions contained in this module. clean.py \"\"\" clean.py contains utility functions for cleaning text. \"\"\" def clean_spaces ( text ): \"\"\" Removes spaces from the input text. Parameters ---------- text the text to be cleaned. Returns ------- the text with all spaces removed. \"\"\" return text . replace ( ' ' , '' ) def clean_underscores ( text ): \"\"\" Removes underscores from the input text. Parameters ---------- text the text to be cleaned. Returns ------- the text with all underscores removed. \"\"\" return text . replace ( '_' , '' ) The tests/test_clean.py module contains functions that test functions in the clean module. Note that there are multiple test functions here for the clean_spaces() function and just one test function for the clean_underscores() function. Each of the functions in the test_clean.py module are test cases. test_clean.py from demo_pytest.clean import clean_spaces , clean_underscores def test___clean_spaces___removes_leading_space (): input_ , expected = \" Hello\" , \"Hello\" assert clean_spaces ( input_ ) == expected def test___clean_spaces___removes_trailing_spaces (): input_ , expected = \"Hello \" , \"Hello\" assert clean_spaces ( input_ ) == expected def test___clean_spaces___removes_bounded_spaces (): input_ , expected = \"Hello There\" , \"HelloThere\" assert clean_spaces ( input_ ) == expected def test___clean_underscores___removes_all_underscores (): input_ , expected = \"_Hello_There_You_\" , \"HelloThereYou\" assert clean_underscores ( input_ ) == expected Pytest will only run tests for clean_spaces() if we use clean_spaces as the filter text: pytest -k \"clean_spaces\" Similarly, the following command runs only those test cases that contain the text clean_underscores in the function name: pytest -k \"clean_underscores\"","title":"Filter Tests"},{"location":"guides/python-naming-rules-conventions/","text":"Rules for Names in Python \u00b6 The rules for names in Python are simple, yet important. One common pitfall is forgetting that names are case sensitive in Python. This means that height and Height are different names in Python. A variable name must start with a letter or the underscore character ( _ ) A variable name cannot start with a number A variable name can only contain alpha-numeric characters and underscores ( A-Z , a-z , 0-9 , and _ ). Variable names are case-sensitive ( age , Age and AGE are three different variables) Where do name rules apply? \u00b6 Name rules apply to all source code and the names of Python files and any directories used in a Python source tree. When Python modules are imported, they become names that are available to our code. Given this, it makes sense that file and directory names in Python source trees must also follow naming rules. PEP8 Conventions for Names \u00b6 Generally speaking, a convention is a widely accepted way of doing things. The same is true for naming conventions. These are not language rules. While they can be broken without affecting program operation, it is generally frowned upon by development teams and the community at large. PEP8 defines some conventions (guidelines) for naming. These are part of the PEP8 style guide. Examples are listed below. Object Category Name Example Style Name variable names births_per_capita snake_case function names get_username() snake_case class names UserProperties() CamelCase module names process_files.py snake_case Other Python Naming Conventions \u00b6 Names with Leading Underscores \u00b6 Names with leading underscores are considered by convention to be private and only to be referenced or called (if functions) from the module in which they are defined. This is not enforced by Python itself, but is often enforced by code checkers in modern CI/CD pipelines. Code completion features in many IDEs and the Python shell itself do not auto-complete names that begin with an underscore. Third-party developers often use such names to discourage end users of the library from referencing variables or calling functions that were not meant to be called directly. Calling dir() . Names with Trailing Underscores \u00b6 It is common practice to use a trailing underscore on a name that would otherwise collide with a built-in or previously defined variable. Consider the following Python code block which collects values into a \"sum\" variable. If the code used the name sum it would overwrite the built-in sum() function which would then be unreachable by subsequent code. trailing_underscores.py matching_product_counts = [ 10 , 20 , 30 , 40 ] sum_ = 0 for count in matching_product_counts : sum_ += count # (1)! print ( f 'Summed in loop: sum_ = { sum_ } ' ) # The loop is unnecessary thanks to Python's sum() sum_ = sum ( matching_product_counts ) # (2)! print ( f 'Summed using built-in sum(): sum_ = { sum_ } ' ) The trailing underscore differentiates the local \"sum\" variable sum_ from the built-in Python function sum() Because sum_ does not overwrite sum() the latter is still available to use as a function. Tip When using a name that is identical to a built-in function, use a trailing underscore to differentiate it from existing name. Use this technique sparingly though and consider using a more meaningful variable name. Warning If you do happen to (or need to) overwrite a built-in name, you can reclaim access to it by removing the name assignment using the del keyword. Example: If you overwrite sum() by assigning sum = 5 , running del sum will reclaim the reference to the built-in sum() . Note that this only works with built-ins. UPPERCASE Names \u00b6 It is convention to use UPPER_CASE (snake case) for names to which constants are defined. For example, the number of minutes in a day never changes in the real world and is therefore a constant if used in a program. Example: MINUTES_PER_DAY = 1440 minutes_so_far = 14_440_000 days_so_far = minutes_so_far / MINUTES_PER_DAY","title":"Rules and Conventions for Names"},{"location":"guides/python-naming-rules-conventions/#rules-for-names-in-python","text":"The rules for names in Python are simple, yet important. One common pitfall is forgetting that names are case sensitive in Python. This means that height and Height are different names in Python. A variable name must start with a letter or the underscore character ( _ ) A variable name cannot start with a number A variable name can only contain alpha-numeric characters and underscores ( A-Z , a-z , 0-9 , and _ ). Variable names are case-sensitive ( age , Age and AGE are three different variables)","title":"Rules for Names in Python"},{"location":"guides/python-naming-rules-conventions/#where-do-name-rules-apply","text":"Name rules apply to all source code and the names of Python files and any directories used in a Python source tree. When Python modules are imported, they become names that are available to our code. Given this, it makes sense that file and directory names in Python source trees must also follow naming rules.","title":"Where do name rules apply?"},{"location":"guides/python-naming-rules-conventions/#pep8-conventions-for-names","text":"Generally speaking, a convention is a widely accepted way of doing things. The same is true for naming conventions. These are not language rules. While they can be broken without affecting program operation, it is generally frowned upon by development teams and the community at large. PEP8 defines some conventions (guidelines) for naming. These are part of the PEP8 style guide. Examples are listed below. Object Category Name Example Style Name variable names births_per_capita snake_case function names get_username() snake_case class names UserProperties() CamelCase module names process_files.py snake_case","title":"PEP8 Conventions for Names"},{"location":"guides/python-naming-rules-conventions/#other-python-naming-conventions","text":"","title":"Other Python Naming Conventions"},{"location":"guides/python-naming-rules-conventions/#names-with-leading-underscores","text":"Names with leading underscores are considered by convention to be private and only to be referenced or called (if functions) from the module in which they are defined. This is not enforced by Python itself, but is often enforced by code checkers in modern CI/CD pipelines. Code completion features in many IDEs and the Python shell itself do not auto-complete names that begin with an underscore. Third-party developers often use such names to discourage end users of the library from referencing variables or calling functions that were not meant to be called directly. Calling dir() .","title":"Names with Leading Underscores"},{"location":"guides/python-naming-rules-conventions/#names-with-trailing-underscores","text":"It is common practice to use a trailing underscore on a name that would otherwise collide with a built-in or previously defined variable. Consider the following Python code block which collects values into a \"sum\" variable. If the code used the name sum it would overwrite the built-in sum() function which would then be unreachable by subsequent code. trailing_underscores.py matching_product_counts = [ 10 , 20 , 30 , 40 ] sum_ = 0 for count in matching_product_counts : sum_ += count # (1)! print ( f 'Summed in loop: sum_ = { sum_ } ' ) # The loop is unnecessary thanks to Python's sum() sum_ = sum ( matching_product_counts ) # (2)! print ( f 'Summed using built-in sum(): sum_ = { sum_ } ' ) The trailing underscore differentiates the local \"sum\" variable sum_ from the built-in Python function sum() Because sum_ does not overwrite sum() the latter is still available to use as a function. Tip When using a name that is identical to a built-in function, use a trailing underscore to differentiate it from existing name. Use this technique sparingly though and consider using a more meaningful variable name. Warning If you do happen to (or need to) overwrite a built-in name, you can reclaim access to it by removing the name assignment using the del keyword. Example: If you overwrite sum() by assigning sum = 5 , running del sum will reclaim the reference to the built-in sum() . Note that this only works with built-ins.","title":"Names with Trailing Underscores"},{"location":"guides/python-naming-rules-conventions/#uppercase-names","text":"It is convention to use UPPER_CASE (snake case) for names to which constants are defined. For example, the number of minutes in a day never changes in the real world and is therefore a constant if used in a program. Example: MINUTES_PER_DAY = 1440 minutes_so_far = 14_440_000 days_so_far = minutes_so_far / MINUTES_PER_DAY","title":"UPPERCASE Names"},{"location":"guides/style-guidelines/","text":"Style Notes for Type Literals \u00b6 PEP8 guidelines make several recommendations that apply to many of the types covered here. The following examples demonstrate how to follow these widely accepted guidelines. String Delimiters \u00b6 In Python, single and double quotes are equivalent. PEP8 makes no recommendation as to which one to use for string delimiters. Decide which one you prefer and use it consistently throughout a single codebase. # WRONG: first_name = \"Jack\" last_name = 'Handy' # mixed quote types for strings # CORRECT: first_name = 'Jack' last_name = 'Handy' # pick one type and use it consistently Sequences \u00b6 Sequences of values or variables are used when defining lists, tuples, dictionaries, and sets. PEP8 makes a general recommendation that a space be included after any comma that is not at the end of a line. When defining these types, include these spaces. The following examples demonstrate: # WRONG: nums = [ 1 , 2 , 3 ] # CORRECT: nums = [ 1 , 2 , 3 ] # WRONG: codes_countries = { 'US' : 'United States' , 'IN' : 'India' } # CORRECT: codes_countries = { 'US' : 'United States' , 'IN' : 'India' } # WRONG: woody_plants = { 'tree' , 'shrub' , 'bush' , 'hedge' } # CORRECT: woody_plants = { 'tree' , 'shrub' , 'bush' , 'hedge' } Spaces After : \u00b6 When defining dictionaries, include a single space after every semicolon : . # WRONG: codes_countries = { 'US' : 'United States' , 'IN' : 'India' } # CORRECT: codes_countries = { 'US' : 'United States' , 'IN' : 'India' }","title":"Style Guidelines"},{"location":"guides/style-guidelines/#style-notes-for-type-literals","text":"PEP8 guidelines make several recommendations that apply to many of the types covered here. The following examples demonstrate how to follow these widely accepted guidelines.","title":"Style Notes for Type Literals"},{"location":"guides/style-guidelines/#string-delimiters","text":"In Python, single and double quotes are equivalent. PEP8 makes no recommendation as to which one to use for string delimiters. Decide which one you prefer and use it consistently throughout a single codebase. # WRONG: first_name = \"Jack\" last_name = 'Handy' # mixed quote types for strings # CORRECT: first_name = 'Jack' last_name = 'Handy' # pick one type and use it consistently","title":"String Delimiters"},{"location":"guides/style-guidelines/#sequences","text":"Sequences of values or variables are used when defining lists, tuples, dictionaries, and sets. PEP8 makes a general recommendation that a space be included after any comma that is not at the end of a line. When defining these types, include these spaces. The following examples demonstrate: # WRONG: nums = [ 1 , 2 , 3 ] # CORRECT: nums = [ 1 , 2 , 3 ] # WRONG: codes_countries = { 'US' : 'United States' , 'IN' : 'India' } # CORRECT: codes_countries = { 'US' : 'United States' , 'IN' : 'India' } # WRONG: woody_plants = { 'tree' , 'shrub' , 'bush' , 'hedge' } # CORRECT: woody_plants = { 'tree' , 'shrub' , 'bush' , 'hedge' }","title":"Sequences"},{"location":"guides/style-guidelines/#spaces-after","text":"When defining dictionaries, include a single space after every semicolon : . # WRONG: codes_countries = { 'US' : 'United States' , 'IN' : 'India' } # CORRECT: codes_countries = { 'US' : 'United States' , 'IN' : 'India' }","title":"Spaces After :"}]}